[{"title":"PostgreSQL + Docker = üíô","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, con...","content":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta pr√°tica de conteineriza√ß√£o possibilita uma configura√ß√£o r√°pida de ambientes de desenvolvimento, testes e produ√ß√£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta gr√°fica de administra√ß√£o que, por sua vez, tamb√©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar v√°rios cont√™ineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSer√° demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar cont√™ineres a partir de imagens](#clock4-criar-cont√™ineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, √© esperado que voc√™ tenha conhecimento b√°sico das tecnologias citadas. Certifique-se de que h√° instalado em sua m√°quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial s√£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) s√£o pontes de comunica√ß√£o que possiblitam √† cont√™ineres uma conex√£o entre eles. Geralmente, criasse uma network quando dois ou mias cont√™ineres t√™m uma rela√ß√£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que ser√° utilizada nesse tutorial, √© poss√≠vel ver quais outras networks est√£o sendo utilizadas em sua m√°quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume √© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o cont√™iner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso ser√° criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua m√°quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar cont√™ineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar √© preciso se atentar √† alguns detalhes:\n  \n- Imagens docker s√£o constru√≠das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tamb√©m t√™m uma vers√£o, geralmente estes s√£o vers√µes do pr√≥prio produto/servi√ßo escolhido, e caso n√£o seja especificado uma vers√£o sempre ser√° instalado a √∫ltima vers√£o est√°vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial ser√° usado a imagem do PostgreSQL vers√£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 voc√™ ir√° usar a √∫ltima vers√£o est√°vel (mais abaixo). Siga o comando a baixo para criar um cont√™iner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta √∫nica linha foi criado e executado um cont√™iner, em que:\n  \n- **-\\-name**, especificao nome do cont√™iner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a vari√°vel de ambiente do cont√™iner\n  - **POSTGRES_PASSWORD=postgresql**, √© a vari√°vel de ambiente que especificaa senha necess√°ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta ser√° exposta (**5440:5432**), ou seja, ser√° acess√≠vel de fora do docker (utilizar em uma aplica√ß√£o n√£o conteinerizada).\n- **-d**, especificaque ap√≥s criado o cont√™iner seu terminal se separe do cont√™iner e voc√™ consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o cont√™iner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o cont√™iner, neste caso a image **postgres**, vers√£o **12.4** utilizando linux **alpine**.\n  \n√â poss√≠vel ver outras vers√µes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um cont√™iner utilizando a imagem do pgAdmin4 em sua √∫ltima vers√£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando √© muito parecido com o utilizado para criar o cont√™iner do Postgres. Est√£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de vari√°veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTamb√©m, por √∫ltimo se encontra o nome da imagem utilizada para criar o cont√™iner (**dpage/pgadmin4**), como pode ver, desta vez n√£o foi passado nenhuma vers√£o especifica, portanto, por padr√£o √© instalado a √∫ltima vers√£o est√°vel da imagem, outro jeito de especificar a √∫ltima vers√£o da imagem √© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJ√° que foi criado os dois cont√™ineres √© hora de testar se tudo est√° funcionando como esperado. Primeiro rode o comando abaixo para listar todos os cont√™ineres em execu√ß√£o em sua m√°quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois cont√™ineres ainda estejam em execu√ß√£o voc√™ deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.s‚Ä¶\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta √© a mesma exposta na cria√ß√£o do cont√™iner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"P√°gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como vari√°veis de ambiente na cria√ß√£o do cont√™iner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVoc√™ ser√° redirecionado para outra p√°gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"P√°gina inicial pgadmin\" width=\"384px\"/>\n  \nPor√©m, ainda n√£o h√° nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o bot√£o direito em cima do \"Servers\" no canto superior esquerdo, v√° em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal ser√° aberto onde voc√™ ir√° inserir informa√ß√µes sobre o servidor. No campo \"name\" adicione um nome de sua prefer√™ncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do cont√™iner \"**postgres**\" (nome do cont√™iner Postgres).\n- No campo \"Port\" utilize a porta interna do cont√™iner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como est√°.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como vari√°vel de ambiente na cria√ß√£o do cont√™iner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no bot√£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVer√° que o servidor foi criado e agora voc√™ tem acesso ao banco de dados do mesmo modo se n√£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados √© o nome do cont√™iner (**postgres**) e a porta √© a interna (**5432**). J√° para acesso externo, como em uma aplica√ß√£o feita em NodeJS, o host √© \"**localhost**\" ou \"**127.0.0.1**\" e a porta √© a porta externa especificada na cria√ß√£o do cont√™iner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de cria√ß√£o dos cont√™ineres pode ser feito utilizando um arquivo que por conven√ß√£o/padr√£o √© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, al√©m disso adiciona o conceito de **stack**.\n  \nStack nada mais √© que um conjunto de cont√™ineres que tem uma rela√ß√£o entre si, voc√™ pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack ser√° o nome da pasta em que o arquivo est√°. Ao criar uma network dentro de uma stack o nome desta network ter√° como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para come√ßar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack ser√° **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua prefer√™ncia e comece adicionando o b√°sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que h√°:\n  \n- **version** - vers√£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, ser√° nomeada **postgres-network**, pois ser√° adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do cont√™iner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma √∫nica linha, ser√° criado um cont√™iner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora √© a vez de reescrever script do cont√™iner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTamb√©m, como no cont√™iner **postgres**, est√° tudo bem parecido com escrito anteriormente utilizando uma √∫nica linha. O nome, email, senha, porta e network continuam o mesmo, por√©m tamb√©m foi adicionado um atributo novo, **depends_on**, este permite que o cont√™iner **pgadmin** n√£o seja criado/iniciado antes do cont√™iner **postgres** ser criado/iniciado.\n  \nPor√©m, antes de executar o arquivo ser√° necess√°rio deletar os cont√™ineres j√° existente afinal n√£o ser√£o mais utilizados como anteriormente, agora eles pertecer√£o √† uma stack. Primeiro pare os dois cont√™ineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os cont√™ineres configurados no arquivo sejam criandos, caso ainda n√£o exista, e os execute. Ainda, quando algo for alterado no arquivo os cont√™ineres afetados ser√£o reconstruidos.\n  \nEm algum momento, caso voc√™ queira parar todos os cont√™ineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, j√° ter um arquivo/script de instala√ß√£o econimiza bastante tempo, afinal n√£o √© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na m√£o.\n  \n> O pregui√ßoso sempre arruma um jeito de n√£o ter trabalho.\n  \nPor fim, agrade√ßo voc√™ por ter chegado at√© aqui, deixe seu coment√°rio e sugest√£o para os pr√≥ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":[{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso voc√™ n√£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conte√∫dos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a m√£o na massa](#botando-a-m√£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [Reorganiza√ß√£o de c√≥digo](#reorganiza√ß√£o-de-c√≥digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada altera√ß√£o importante no c√≥digo fazer um commit. Isso permite que caso algo d√™ errado seja poss√≠vel recuperar a √∫ltima vers√£o correta do c√≥digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJ√° temos nossa organiza√ß√£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e come√ßarmos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de c√≥digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o pr√≥ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a m√£o na massa\nCom a pasta **server_node** aberta no VS Code como diret√≥rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora √© preciso apenas come√ßar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma vari√°vel, no nosso caso **app**,  como uma fun√ß√£o.\n\nAgora, diga ao **app** escutar requisi√ß√µes na porta 3000, como est√° abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui √† app como uma fun√ß√£o\nconst app = express()\n\n// inicia servidor escutando requisi√ß√µes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente come√ßou, temos um servidor que escuta na porta 3000 da nossa m√°quina, por√©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplica√ß√µes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requi√ß√£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisi√ß√µes HTTP\n - falamos para o app/express utilizar o cors em sua execu√ß√£o\n - falamos para o app/express utilizar o morgan em sua execu√ß√£o\n - finalmente, criamos uma rota com o m√©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o b√°sico b√°sico de um servidor em node, por√©m at√© agora n√£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor √© um programa que fica sempre em execu√ß√£o, apenas interrompido quando h√° algum erro ou outro programa/usu√°rio for√ßa sua interrup√ß√£o, ele ficar√° esperando requisi√ß√µes. Portanto, fa√ßa uma requisi√ß√£o, pelo pr√≥prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, voc√™ receber√° um **ok** na p√°gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, por√©m tamb√©m n√£o se reinicia quando fizermos alguma altera√ß√£o no c√≥digo, para isso preparamos o script **dev**. Portanto, interrompa a execu√ß√£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJ√° que programamos nossa primeira rota, √© hora de realmente retornar ao usu√°rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois m√≥dulos padr√µes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, prov√™ m√©todos para facilmente trabalhar com caminhos dentro do node\n- fs, prov√™ m√©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na vari√°vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o m√©todo **readFileSync** do m√≥dulo **fs** (sempre retorna string)\n - Fazemos o parse/transforma√ß√£o da string para o formato json\n - Retornamos o json para o usu√°rio\n\n√â pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // L√™ de forma s√≠ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usu√°rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto √© poss√≠vel ver como funciona um servidor API Rest, o usu√°rio faz uma requisi√ß√£o e o retorno √© apenas em json, nada de HTML.\n\nNosso c√≥digo est√° bem enxuto, e queremos isto, algo simples, de f√°cil entendimento, por√©m que resolva o proposto. Por√©m, n√£o estamos tratando nenhuma exce√ß√£o ou erro que possa acontecer durante a execu√ß√£o.\n\nPara resolver esse problema vamos envolver todo o conte√∫do dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usu√°rio. Mas ainda n√£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usu√°rio de c√≥digo 200, e caso d√™ algum problema durante a execu√ß√£o do nosso c√≥digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usu√°rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execu√ß√£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento j√° estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. Ent√£o, no pr√≥ximo criaremos a leitura de um dado apenas, baseado na rota que o usu√°rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os m√©todo GET novamente, por√©m, utilizaremos uma rota din√¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este n√∫mero adicional na rota nos dar√° a capacidade de retornarmos ao usu√°rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisi√ß√£o do usu√°rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisi√ß√µes com metodo GET com um par√¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisi√ß√£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma vari√°vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a vari√°vel n√£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usu√°rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nTemos as duas requisi√ß√µes com o m√©todo GET, para quando o usu√°rio pedir todos os fatos e quando pedir apenas um fato com um espec√≠fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usu√°rio seja capaz de criar um novo fato. \nNo corpo da requisi√ß√£o pegaremos todos os campos necess√°rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade √©:\n- ouvir requisi√ß√µes com o m√©todo POST\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto com as propriedades necess√°rias, id, text, type e upvotes\n- adicionar o novo fato √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com metodo POST\napp.post('/', (request, response) => {\n\t// l√™ o campo text do corpo da requisi√ß√£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usu√°rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n### ALTERAR\nJ√° que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usu√°rio altere algum fato em nosso arquivo/banco a partir da rota din√¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez √©:\n- ouvir requisi√ß√µes com o m√©todo PUT e ID\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com m√©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisi√ß√£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas vari√°veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// vari√°vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usu√°rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da altera√ß√£o, precisando do ID da rota, por√©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, √©:\n- ouvir requisi√ß√µes com o m√©todo DELETE e ID\n- ler arquivo e guardar em uma vari√°vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com o m√©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma vari√°vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o √≠ndice do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do √≠ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n\n# Reorganiza√ß√£o de c√≥digo\n## Criando controller\nSe voc√™ olhar para seu arquivo **server.js**  ele est√° enorme e √© dif√≠cil sua leitura, al√©m de que eventualmente n√≥s podemos querer acrescentar mais funcionalidades, portando, mais c√≥digo ao nosso projeto. \nPara uma melhor manuten√ß√£o √© importante separarmos aquilo que √© de inicializa√ß√£o/configura√ß√£o do servidor do que √© funcionalidade para o usu√°rio.\nEnt√£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara come√ßar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os m√≥dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a vari√°vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 m√©todos, index, show, create, update e delete, todos com os mesmo par√¢metros, request e  response, e ao final exportaremos a classe como um m√≥dulo.\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO pr√≥ximo passo para organizarmos nosso c√≥digo √© mover algumas partes de c√≥digo que est√£o no **server.js** para este arquivo. Portanto, todo o c√≥digo dentro de `app.get('/', (request, response){...})` ficar√° dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usu√°rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nO mesmo ser√° feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora n√£o est√° se comunicando com o servidor/Express e para deixar nosso c√≥digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diret√≥rio do arquivo **server.js**. Este arquivo ir√° conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um m√≥dulo, usando **./controllers/FactsController** para sinalizar que √© um m√≥dulo criado no projeto. Importaremos tamb√©m o m√≥dulo Express, por√©m, dessa vez iniciaremos um roteador, e n√£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um m√≥dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos c√≥digos que n√£o est√£o mais sendo usados pelo servidor. Ent√£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja f√°cil a manuten√ß√£o, ainda n√£o √© o ideal, mas √© o suficiente!\n\nSe voc√™ chegou at√© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu pr√≥prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma s√©rie de posts envolvendo o desenvolvimento de aplica√ß√µes Back End e Front End.\n\nDeixe seu coment√°rio dizendo o que est√° bom e o que √© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":["[Circular ~.0]",{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, √© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo s√£o listados alguns dos conhecimentos que ser√£o descritos e ensinados neste tutorial:\n\n- Boas pr√°ticas de programa√ß√£o\n- Defini√ß√£o de um sistema de pastas simples e eficiente\n- Iniciar um reposit√≥rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de come√ßar √© preciso certificar-se de que alguns programas est√£o instalados na m√°quina que ser√° utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execu√ß√£o de c√≥digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de c√≥digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de c√≥digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisi√ß√µes HTTP.\n\n√â necess√°rio criar uma conta criada no [GitHub](https://github.com/). O GitHub √© a plataforma de hospedagem de c√≥digo-fonte e possui controle de vers√£o. Essa plataforma poder√° auxiliar no transporte do c√≥digo para outro lugar, como para a faculdade ou trabalho.\n\n√â importante saber o que √© um servidor REST, o que √© HTTP e como utilizar o Insomnia para fazer requisi√ß√µes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que est√° sendo montado:\n\n- [O que √© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (v√≠deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir s√£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conte√∫dos\n- [Criando pastas](#criando-pastas)\n- [Criando um reposit√≥rio utilizando GitHub](#criando-um-reposit√≥rio-utilizando-github)\n- [Criando um reposit√≥rio sem GitHub](#criando-um-reposit√≥rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [Dom√≠nio](#dom√≠nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [Cabe√ßalhos](#cabe√ßalhos)\n\t\t- [M√©todos](#m√©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [Par√¢metros (Query String)](#par√¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com par√¢metros](#get-com-par√¢metros)\n\t\t- [GET com rota din√¢mica](#get-com-rota-din√¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara come√ßar ser√° criada uma pasta inicial chamada **server_node**. Ap√≥s cri√°-la √© necess√°rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois √© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto s√£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. Por√©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estar√£o os c√≥digos que controlaram as funcionalidade do usu√°rio, e outra chamada **db**. Na pasta db estar√£o todas a informa√ß√£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas √© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os pr√≥ximos passo √© necess√°rio que o diret√≥rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diret√≥rio atual √© **src** dentro de **server_node**. Para voltar diret√≥rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um reposit√≥rio utilizando GitHub\n\nCaso voc√™ tenha uma conta criada no GitHub, [crie um novo reposit√≥rio](https://github.com/new) com nome **server_node**, sem gitignore, licen√ßa e readme.\nLogo ap√≥s criado o reposit√≥rio ir√° aparecer algumas op√ß√µes para iniciar o mesmo. Copie todo o conte√∫do da op√ß√£o **criar um novo reposit√≥rio usando linha de comando**, no meu caso o c√≥digo √© o mostrado abaixo. Cole o conte√∫do no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conte√∫do \"# server_node\"\ngit init # inicia um reposit√≥rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu reposit√≥rio para o GitHub\n```\n\n# Criando um reposit√≥rio sem GitHub\n\nCaso voc√™ n√£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o c√≥digo abaixo para iniciar seu versionamento de c√≥digo local.\n\n```bash\ngit init # inicia reposit√≥rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS √© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descri√ß√£o do projeto\n- version, vers√£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licen√ßa utilizada no projeto\n- private, se este projeto pode ser public√°vel ou n√£o\n- scripts, comandos de execu√ß√£o\n- dependencies, depend√™ncias principais do projeto\n- devdependencies, depend√™ncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na m√£o, √© muito mais f√°cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, ap√≥s executar, ser√° necess√°rio preencher alguns dados, como √© mostrado abaixo.\n\n```bash\nyarn init # inicia reposit√≥rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes s√£o m√≥dulos, c√≥digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome j√° sugere, pacotes principais s√£o m√≥dulos que seu c√≥digo ir√° precisar mesmo quando em produ√ß√£o e pacotes de desenvolvimento s√£o m√≥dulos que voc√™ usar√° apenas quando estiver programando.\nM√≥dulos que usaremos s√£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplica√ß√£o fa√ßa requisi√ß√£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisi√ß√£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada altera√ß√£o no c√≥digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** √© criada, nela est√° todos os pacotes baixados. Ainda, note que cada vez que voc√™ adiciona ou remove um pacote o arquivo **package.json** √© alterado. Isso serve para caso voc√™ precise copiar seu c√≥digo para outra m√°quina, voc√™ n√£o precise copiar a pasta **node_modules** junto, e seja necess√°rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** ser√£o instalados e automaticamente ser√° criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** ser√° o script para executarmos o servidor em desenvolvimento, reiniciando a cada modifica√ß√£o no c√≥digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** ser√° o script que utilizaremos quando quisermos executar nosso servidor em produ√ß√£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e depend√™ncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de come√ßarmos a codar precisamos lembrar de alguns conceitos de requisi√ß√µes HTTP.\nPara fazermos uma requisi√ß√£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o dom√≠nio, a porta, a rota, os cabe√ßalhos (headers), o corpo (body) e os par√¢metros (query string).\n\n## Dom√≠nio\n\nDom√≠nio, de forma bem ampla, √© o nome do servidor, este √© um jeito utilizado para n√£o precisarmos escrever o IP de todo site que quisermos acessar. O dom√≠nio, assim como o IP, √© √∫nico e √© reconhecido por toda a internet. Como exemplo, a Google tem um dom√≠nio global `google.com`\nque por tr√°s est√° um IP `172.217.28.78`.\n\nA √∫nica exce√ß√£o de dom√≠nio e IP que se repete em toda m√°quina √© o local. Toda m√°quina m√°quina consegue se acessar usando o dom√≠nio local `localhost` e IP `127.0.0.1`, portanto uma m√°quina n√£o consegue acessar um aplica√ß√£o de outra m√°quina utilizando o dom√≠nio `localhost`, pois ela tentar√° acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, s√£o conex√µes de cada aplica√ß√£o dentro da nossa m√°quina. Cada aplica√ß√£o utiliza uma ou mais portas para se comunicar com outra aplica√ß√£o, internamente ou n√£o. Em nossa m√°quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padr√£o HTTP utiliza a porta 80, por isso muita das vezes n√£o precisamos explicitamente colocar a porta ao acessar um site.\nFa√ßa o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso voc√™ conseguir√° acessar o site, por√©m no seguindo caso o navegador n√£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, por√©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, √© o caminho em que o usu√°rio faz uma requisi√ß√£o ao servidor.\nSendo assim, um caminho dita qual conte√∫do voc√™ espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a p√°gina de busca do site `/` , j√° no segundo caso pedimos ao servidor do google que nos mostre a p√°gina doodles `/doodles/`.\n\nServidores t√™m a possibilidade tamb√©m de criar rotas din√¢micas, estas s√£o rotas geradas automaticamente para requisi√ß√£o de um dado espec√≠fico mas que o tratamento desse dado √© gen√©rico. Como, buscar dados de um usu√°rio espec√≠fico. O servidor ir√° retornar os dados apenas daquele usu√°rio, por√©m o tratamento no servidor √© gen√©rico, de forma que consiga buscar qualquer usu√°rio dentro do banco de dados.\n\n## Cabe√ßalhos\n\nOs cabe√ßalhos t√™m informa√ß√µes importantes sobre o usu√°rio e tamb√©m sobre o servidor (no retorno).\nNos cabe√ßalhos conseguimos encontrar o m√©todo/verbo da requisi√ß√£o (GET, POST, PUT, DELETE, entre outros), o tipo do conte√∫do da requisi√ß√£o, o tamanho do conte√∫do enviado na requisi√ß√£o, qual aplica√ß√£o fez a requisi√ß√£o, o dom√≠nio em que o usu√°rio est√°, entre outros.\n\n### M√©todos\n\nComo dito antes, nos cabe√ßalhos √© poss√≠vel encontrar o m√©todo/verbo da requisi√ß√£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conte√∫dos do cabe√ßalho, no servidores com **Express** sempre precisamos falar quais m√©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padr√£o utilizam apenas os m√©todos GET e POST, portanto, para utilizar outro m√©todo √© necess√°rio utilizar JavaScript em uma requisi√ß√£o.\n\n#### GET\n\nPor padr√£o √© utilizado quando queremos apenas o retorno de algum dado/p√°gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usu√°rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor, por√©m, desta vez estamos modificando um dado j√° existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo √© um espa√ßo na requisi√ß√£o HTTP onde os dados de um formul√°rio s√£o enviados ao servidor. H√° v√°rios tipos de conte√∫dos que podem ser enviados no corpo, por isso do campo `tipo de cont√©udo` dentro dos cabe√ßalhos.\n\n## Par√¢metros (Query String)\n\nPar√¢metros, como o nome j√° indica, s√£o par√¢metros que passamos junto a rota, geralmente s√£o utilizados como filtros para alguma requisi√ß√£o.\n\nUm exemplo de par√¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um par√¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais par√¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os par√¢metros s√£o utilizados junto ao m√©todo GET, para filtragem de resultados no servidor. Por√©m nada impede de ser usados junto a outro m√©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- M√©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com par√¢metros\n\n- M√©todo: GET\n- Rota: /nomes\n- Par√¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho m√°ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota din√¢mica\n\n- M√©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informa√ß√µes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- M√©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- M√©todo: PUT\n- Rota din√¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- M√©todo: DELETE\n- Rota din√¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso reposit√≥rio, iniciamos o projeto com Yarn, instalamos alguns m√≥dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisi√ß√£o HTTP.\n\nAgora estamos prontos para ir para a pr√≥xima fase, onde realmente colocamos a m√£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de voc√™ ter chegado at√© aqui! Espero que eu tenha lhe passado algum conhecimento. Ent√£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":["[Circular ~.0]","[Circular ~.0.suggestions.0]"]}]},{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, √© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo s√£o listados alguns dos conhecimentos que ser√£o descritos e ensinados neste tutorial:\n\n- Boas pr√°ticas de programa√ß√£o\n- Defini√ß√£o de um sistema de pastas simples e eficiente\n- Iniciar um reposit√≥rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de come√ßar √© preciso certificar-se de que alguns programas est√£o instalados na m√°quina que ser√° utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execu√ß√£o de c√≥digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de c√≥digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de c√≥digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisi√ß√µes HTTP.\n\n√â necess√°rio criar uma conta criada no [GitHub](https://github.com/). O GitHub √© a plataforma de hospedagem de c√≥digo-fonte e possui controle de vers√£o. Essa plataforma poder√° auxiliar no transporte do c√≥digo para outro lugar, como para a faculdade ou trabalho.\n\n√â importante saber o que √© um servidor REST, o que √© HTTP e como utilizar o Insomnia para fazer requisi√ß√µes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que est√° sendo montado:\n\n- [O que √© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (v√≠deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir s√£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conte√∫dos\n- [Criando pastas](#criando-pastas)\n- [Criando um reposit√≥rio utilizando GitHub](#criando-um-reposit√≥rio-utilizando-github)\n- [Criando um reposit√≥rio sem GitHub](#criando-um-reposit√≥rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [Dom√≠nio](#dom√≠nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [Cabe√ßalhos](#cabe√ßalhos)\n\t\t- [M√©todos](#m√©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [Par√¢metros (Query String)](#par√¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com par√¢metros](#get-com-par√¢metros)\n\t\t- [GET com rota din√¢mica](#get-com-rota-din√¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara come√ßar ser√° criada uma pasta inicial chamada **server_node**. Ap√≥s cri√°-la √© necess√°rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois √© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto s√£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. Por√©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estar√£o os c√≥digos que controlaram as funcionalidade do usu√°rio, e outra chamada **db**. Na pasta db estar√£o todas a informa√ß√£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas √© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os pr√≥ximos passo √© necess√°rio que o diret√≥rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diret√≥rio atual √© **src** dentro de **server_node**. Para voltar diret√≥rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um reposit√≥rio utilizando GitHub\n\nCaso voc√™ tenha uma conta criada no GitHub, [crie um novo reposit√≥rio](https://github.com/new) com nome **server_node**, sem gitignore, licen√ßa e readme.\nLogo ap√≥s criado o reposit√≥rio ir√° aparecer algumas op√ß√µes para iniciar o mesmo. Copie todo o conte√∫do da op√ß√£o **criar um novo reposit√≥rio usando linha de comando**, no meu caso o c√≥digo √© o mostrado abaixo. Cole o conte√∫do no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conte√∫do \"# server_node\"\ngit init # inicia um reposit√≥rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu reposit√≥rio para o GitHub\n```\n\n# Criando um reposit√≥rio sem GitHub\n\nCaso voc√™ n√£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o c√≥digo abaixo para iniciar seu versionamento de c√≥digo local.\n\n```bash\ngit init # inicia reposit√≥rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS √© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descri√ß√£o do projeto\n- version, vers√£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licen√ßa utilizada no projeto\n- private, se este projeto pode ser public√°vel ou n√£o\n- scripts, comandos de execu√ß√£o\n- dependencies, depend√™ncias principais do projeto\n- devdependencies, depend√™ncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na m√£o, √© muito mais f√°cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, ap√≥s executar, ser√° necess√°rio preencher alguns dados, como √© mostrado abaixo.\n\n```bash\nyarn init # inicia reposit√≥rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes s√£o m√≥dulos, c√≥digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome j√° sugere, pacotes principais s√£o m√≥dulos que seu c√≥digo ir√° precisar mesmo quando em produ√ß√£o e pacotes de desenvolvimento s√£o m√≥dulos que voc√™ usar√° apenas quando estiver programando.\nM√≥dulos que usaremos s√£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplica√ß√£o fa√ßa requisi√ß√£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisi√ß√£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada altera√ß√£o no c√≥digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** √© criada, nela est√° todos os pacotes baixados. Ainda, note que cada vez que voc√™ adiciona ou remove um pacote o arquivo **package.json** √© alterado. Isso serve para caso voc√™ precise copiar seu c√≥digo para outra m√°quina, voc√™ n√£o precise copiar a pasta **node_modules** junto, e seja necess√°rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** ser√£o instalados e automaticamente ser√° criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** ser√° o script para executarmos o servidor em desenvolvimento, reiniciando a cada modifica√ß√£o no c√≥digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** ser√° o script que utilizaremos quando quisermos executar nosso servidor em produ√ß√£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e depend√™ncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de come√ßarmos a codar precisamos lembrar de alguns conceitos de requisi√ß√µes HTTP.\nPara fazermos uma requisi√ß√£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o dom√≠nio, a porta, a rota, os cabe√ßalhos (headers), o corpo (body) e os par√¢metros (query string).\n\n## Dom√≠nio\n\nDom√≠nio, de forma bem ampla, √© o nome do servidor, este √© um jeito utilizado para n√£o precisarmos escrever o IP de todo site que quisermos acessar. O dom√≠nio, assim como o IP, √© √∫nico e √© reconhecido por toda a internet. Como exemplo, a Google tem um dom√≠nio global `google.com`\nque por tr√°s est√° um IP `172.217.28.78`.\n\nA √∫nica exce√ß√£o de dom√≠nio e IP que se repete em toda m√°quina √© o local. Toda m√°quina m√°quina consegue se acessar usando o dom√≠nio local `localhost` e IP `127.0.0.1`, portanto uma m√°quina n√£o consegue acessar um aplica√ß√£o de outra m√°quina utilizando o dom√≠nio `localhost`, pois ela tentar√° acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, s√£o conex√µes de cada aplica√ß√£o dentro da nossa m√°quina. Cada aplica√ß√£o utiliza uma ou mais portas para se comunicar com outra aplica√ß√£o, internamente ou n√£o. Em nossa m√°quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padr√£o HTTP utiliza a porta 80, por isso muita das vezes n√£o precisamos explicitamente colocar a porta ao acessar um site.\nFa√ßa o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso voc√™ conseguir√° acessar o site, por√©m no seguindo caso o navegador n√£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, por√©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, √© o caminho em que o usu√°rio faz uma requisi√ß√£o ao servidor.\nSendo assim, um caminho dita qual conte√∫do voc√™ espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a p√°gina de busca do site `/` , j√° no segundo caso pedimos ao servidor do google que nos mostre a p√°gina doodles `/doodles/`.\n\nServidores t√™m a possibilidade tamb√©m de criar rotas din√¢micas, estas s√£o rotas geradas automaticamente para requisi√ß√£o de um dado espec√≠fico mas que o tratamento desse dado √© gen√©rico. Como, buscar dados de um usu√°rio espec√≠fico. O servidor ir√° retornar os dados apenas daquele usu√°rio, por√©m o tratamento no servidor √© gen√©rico, de forma que consiga buscar qualquer usu√°rio dentro do banco de dados.\n\n## Cabe√ßalhos\n\nOs cabe√ßalhos t√™m informa√ß√µes importantes sobre o usu√°rio e tamb√©m sobre o servidor (no retorno).\nNos cabe√ßalhos conseguimos encontrar o m√©todo/verbo da requisi√ß√£o (GET, POST, PUT, DELETE, entre outros), o tipo do conte√∫do da requisi√ß√£o, o tamanho do conte√∫do enviado na requisi√ß√£o, qual aplica√ß√£o fez a requisi√ß√£o, o dom√≠nio em que o usu√°rio est√°, entre outros.\n\n### M√©todos\n\nComo dito antes, nos cabe√ßalhos √© poss√≠vel encontrar o m√©todo/verbo da requisi√ß√£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conte√∫dos do cabe√ßalho, no servidores com **Express** sempre precisamos falar quais m√©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padr√£o utilizam apenas os m√©todos GET e POST, portanto, para utilizar outro m√©todo √© necess√°rio utilizar JavaScript em uma requisi√ß√£o.\n\n#### GET\n\nPor padr√£o √© utilizado quando queremos apenas o retorno de algum dado/p√°gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usu√°rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor, por√©m, desta vez estamos modificando um dado j√° existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo √© um espa√ßo na requisi√ß√£o HTTP onde os dados de um formul√°rio s√£o enviados ao servidor. H√° v√°rios tipos de conte√∫dos que podem ser enviados no corpo, por isso do campo `tipo de cont√©udo` dentro dos cabe√ßalhos.\n\n## Par√¢metros (Query String)\n\nPar√¢metros, como o nome j√° indica, s√£o par√¢metros que passamos junto a rota, geralmente s√£o utilizados como filtros para alguma requisi√ß√£o.\n\nUm exemplo de par√¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um par√¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais par√¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os par√¢metros s√£o utilizados junto ao m√©todo GET, para filtragem de resultados no servidor. Por√©m nada impede de ser usados junto a outro m√©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- M√©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com par√¢metros\n\n- M√©todo: GET\n- Rota: /nomes\n- Par√¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho m√°ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota din√¢mica\n\n- M√©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informa√ß√µes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- M√©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- M√©todo: PUT\n- Rota din√¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- M√©todo: DELETE\n- Rota din√¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso reposit√≥rio, iniciamos o projeto com Yarn, instalamos alguns m√≥dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisi√ß√£o HTTP.\n\nAgora estamos prontos para ir para a pr√≥xima fase, onde realmente colocamos a m√£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de voc√™ ter chegado at√© aqui! Espero que eu tenha lhe passado algum conhecimento. Ent√£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":["[Circular ~.0]",{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso voc√™ n√£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conte√∫dos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a m√£o na massa](#botando-a-m√£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [Reorganiza√ß√£o de c√≥digo](#reorganiza√ß√£o-de-c√≥digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada altera√ß√£o importante no c√≥digo fazer um commit. Isso permite que caso algo d√™ errado seja poss√≠vel recuperar a √∫ltima vers√£o correta do c√≥digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJ√° temos nossa organiza√ß√£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e come√ßarmos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de c√≥digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o pr√≥ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a m√£o na massa\nCom a pasta **server_node** aberta no VS Code como diret√≥rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora √© preciso apenas come√ßar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma vari√°vel, no nosso caso **app**,  como uma fun√ß√£o.\n\nAgora, diga ao **app** escutar requisi√ß√µes na porta 3000, como est√° abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui √† app como uma fun√ß√£o\nconst app = express()\n\n// inicia servidor escutando requisi√ß√µes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente come√ßou, temos um servidor que escuta na porta 3000 da nossa m√°quina, por√©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplica√ß√µes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requi√ß√£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisi√ß√µes HTTP\n - falamos para o app/express utilizar o cors em sua execu√ß√£o\n - falamos para o app/express utilizar o morgan em sua execu√ß√£o\n - finalmente, criamos uma rota com o m√©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o b√°sico b√°sico de um servidor em node, por√©m at√© agora n√£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor √© um programa que fica sempre em execu√ß√£o, apenas interrompido quando h√° algum erro ou outro programa/usu√°rio for√ßa sua interrup√ß√£o, ele ficar√° esperando requisi√ß√µes. Portanto, fa√ßa uma requisi√ß√£o, pelo pr√≥prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, voc√™ receber√° um **ok** na p√°gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, por√©m tamb√©m n√£o se reinicia quando fizermos alguma altera√ß√£o no c√≥digo, para isso preparamos o script **dev**. Portanto, interrompa a execu√ß√£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJ√° que programamos nossa primeira rota, √© hora de realmente retornar ao usu√°rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois m√≥dulos padr√µes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, prov√™ m√©todos para facilmente trabalhar com caminhos dentro do node\n- fs, prov√™ m√©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na vari√°vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o m√©todo **readFileSync** do m√≥dulo **fs** (sempre retorna string)\n - Fazemos o parse/transforma√ß√£o da string para o formato json\n - Retornamos o json para o usu√°rio\n\n√â pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // L√™ de forma s√≠ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usu√°rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto √© poss√≠vel ver como funciona um servidor API Rest, o usu√°rio faz uma requisi√ß√£o e o retorno √© apenas em json, nada de HTML.\n\nNosso c√≥digo est√° bem enxuto, e queremos isto, algo simples, de f√°cil entendimento, por√©m que resolva o proposto. Por√©m, n√£o estamos tratando nenhuma exce√ß√£o ou erro que possa acontecer durante a execu√ß√£o.\n\nPara resolver esse problema vamos envolver todo o conte√∫do dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usu√°rio. Mas ainda n√£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usu√°rio de c√≥digo 200, e caso d√™ algum problema durante a execu√ß√£o do nosso c√≥digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usu√°rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execu√ß√£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento j√° estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. Ent√£o, no pr√≥ximo criaremos a leitura de um dado apenas, baseado na rota que o usu√°rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os m√©todo GET novamente, por√©m, utilizaremos uma rota din√¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este n√∫mero adicional na rota nos dar√° a capacidade de retornarmos ao usu√°rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisi√ß√£o do usu√°rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisi√ß√µes com metodo GET com um par√¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisi√ß√£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma vari√°vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a vari√°vel n√£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usu√°rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nTemos as duas requisi√ß√µes com o m√©todo GET, para quando o usu√°rio pedir todos os fatos e quando pedir apenas um fato com um espec√≠fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usu√°rio seja capaz de criar um novo fato. \nNo corpo da requisi√ß√£o pegaremos todos os campos necess√°rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade √©:\n- ouvir requisi√ß√µes com o m√©todo POST\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto com as propriedades necess√°rias, id, text, type e upvotes\n- adicionar o novo fato √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com metodo POST\napp.post('/', (request, response) => {\n\t// l√™ o campo text do corpo da requisi√ß√£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usu√°rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n### ALTERAR\nJ√° que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usu√°rio altere algum fato em nosso arquivo/banco a partir da rota din√¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez √©:\n- ouvir requisi√ß√µes com o m√©todo PUT e ID\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com m√©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisi√ß√£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas vari√°veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// vari√°vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usu√°rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da altera√ß√£o, precisando do ID da rota, por√©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, √©:\n- ouvir requisi√ß√µes com o m√©todo DELETE e ID\n- ler arquivo e guardar em uma vari√°vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com o m√©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma vari√°vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o √≠ndice do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do √≠ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n\n# Reorganiza√ß√£o de c√≥digo\n## Criando controller\nSe voc√™ olhar para seu arquivo **server.js**  ele est√° enorme e √© dif√≠cil sua leitura, al√©m de que eventualmente n√≥s podemos querer acrescentar mais funcionalidades, portando, mais c√≥digo ao nosso projeto. \nPara uma melhor manuten√ß√£o √© importante separarmos aquilo que √© de inicializa√ß√£o/configura√ß√£o do servidor do que √© funcionalidade para o usu√°rio.\nEnt√£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara come√ßar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os m√≥dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a vari√°vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 m√©todos, index, show, create, update e delete, todos com os mesmo par√¢metros, request e  response, e ao final exportaremos a classe como um m√≥dulo.\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO pr√≥ximo passo para organizarmos nosso c√≥digo √© mover algumas partes de c√≥digo que est√£o no **server.js** para este arquivo. Portanto, todo o c√≥digo dentro de `app.get('/', (request, response){...})` ficar√° dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usu√°rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nO mesmo ser√° feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora n√£o est√° se comunicando com o servidor/Express e para deixar nosso c√≥digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diret√≥rio do arquivo **server.js**. Este arquivo ir√° conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um m√≥dulo, usando **./controllers/FactsController** para sinalizar que √© um m√≥dulo criado no projeto. Importaremos tamb√©m o m√≥dulo Express, por√©m, dessa vez iniciaremos um roteador, e n√£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um m√≥dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos c√≥digos que n√£o est√£o mais sendo usados pelo servidor. Ent√£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja f√°cil a manuten√ß√£o, ainda n√£o √© o ideal, mas √© o suficiente!\n\nSe voc√™ chegou at√© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu pr√≥prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma s√©rie de posts envolvendo o desenvolvimento de aplica√ß√µes Back End e Front End.\n\nDeixe seu coment√°rio dizendo o que est√° bom e o que √© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":["[Circular ~.0]","[Circular ~.0.suggestions.1]"]}]}]},{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso voc√™ n√£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conte√∫dos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a m√£o na massa](#botando-a-m√£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [Reorganiza√ß√£o de c√≥digo](#reorganiza√ß√£o-de-c√≥digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada altera√ß√£o importante no c√≥digo fazer um commit. Isso permite que caso algo d√™ errado seja poss√≠vel recuperar a √∫ltima vers√£o correta do c√≥digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJ√° temos nossa organiza√ß√£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e come√ßarmos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de c√≥digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o pr√≥ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a m√£o na massa\nCom a pasta **server_node** aberta no VS Code como diret√≥rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora √© preciso apenas come√ßar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma vari√°vel, no nosso caso **app**,  como uma fun√ß√£o.\n\nAgora, diga ao **app** escutar requisi√ß√µes na porta 3000, como est√° abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui √† app como uma fun√ß√£o\nconst app = express()\n\n// inicia servidor escutando requisi√ß√µes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente come√ßou, temos um servidor que escuta na porta 3000 da nossa m√°quina, por√©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplica√ß√µes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requi√ß√£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisi√ß√µes HTTP\n - falamos para o app/express utilizar o cors em sua execu√ß√£o\n - falamos para o app/express utilizar o morgan em sua execu√ß√£o\n - finalmente, criamos uma rota com o m√©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o b√°sico b√°sico de um servidor em node, por√©m at√© agora n√£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor √© um programa que fica sempre em execu√ß√£o, apenas interrompido quando h√° algum erro ou outro programa/usu√°rio for√ßa sua interrup√ß√£o, ele ficar√° esperando requisi√ß√µes. Portanto, fa√ßa uma requisi√ß√£o, pelo pr√≥prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, voc√™ receber√° um **ok** na p√°gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, por√©m tamb√©m n√£o se reinicia quando fizermos alguma altera√ß√£o no c√≥digo, para isso preparamos o script **dev**. Portanto, interrompa a execu√ß√£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJ√° que programamos nossa primeira rota, √© hora de realmente retornar ao usu√°rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois m√≥dulos padr√µes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, prov√™ m√©todos para facilmente trabalhar com caminhos dentro do node\n- fs, prov√™ m√©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na vari√°vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o m√©todo **readFileSync** do m√≥dulo **fs** (sempre retorna string)\n - Fazemos o parse/transforma√ß√£o da string para o formato json\n - Retornamos o json para o usu√°rio\n\n√â pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // L√™ de forma s√≠ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usu√°rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto √© poss√≠vel ver como funciona um servidor API Rest, o usu√°rio faz uma requisi√ß√£o e o retorno √© apenas em json, nada de HTML.\n\nNosso c√≥digo est√° bem enxuto, e queremos isto, algo simples, de f√°cil entendimento, por√©m que resolva o proposto. Por√©m, n√£o estamos tratando nenhuma exce√ß√£o ou erro que possa acontecer durante a execu√ß√£o.\n\nPara resolver esse problema vamos envolver todo o conte√∫do dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usu√°rio. Mas ainda n√£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usu√°rio de c√≥digo 200, e caso d√™ algum problema durante a execu√ß√£o do nosso c√≥digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usu√°rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execu√ß√£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento j√° estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. Ent√£o, no pr√≥ximo criaremos a leitura de um dado apenas, baseado na rota que o usu√°rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os m√©todo GET novamente, por√©m, utilizaremos uma rota din√¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este n√∫mero adicional na rota nos dar√° a capacidade de retornarmos ao usu√°rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisi√ß√£o do usu√°rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisi√ß√µes com metodo GET com um par√¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisi√ß√£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma vari√°vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a vari√°vel n√£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usu√°rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nTemos as duas requisi√ß√µes com o m√©todo GET, para quando o usu√°rio pedir todos os fatos e quando pedir apenas um fato com um espec√≠fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usu√°rio seja capaz de criar um novo fato. \nNo corpo da requisi√ß√£o pegaremos todos os campos necess√°rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade √©:\n- ouvir requisi√ß√µes com o m√©todo POST\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto com as propriedades necess√°rias, id, text, type e upvotes\n- adicionar o novo fato √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com metodo POST\napp.post('/', (request, response) => {\n\t// l√™ o campo text do corpo da requisi√ß√£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usu√°rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n### ALTERAR\nJ√° que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usu√°rio altere algum fato em nosso arquivo/banco a partir da rota din√¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez √©:\n- ouvir requisi√ß√µes com o m√©todo PUT e ID\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com m√©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisi√ß√£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas vari√°veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// vari√°vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usu√°rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da altera√ß√£o, precisando do ID da rota, por√©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, √©:\n- ouvir requisi√ß√µes com o m√©todo DELETE e ID\n- ler arquivo e guardar em uma vari√°vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com o m√©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma vari√°vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o √≠ndice do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do √≠ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n\n# Reorganiza√ß√£o de c√≥digo\n## Criando controller\nSe voc√™ olhar para seu arquivo **server.js**  ele est√° enorme e √© dif√≠cil sua leitura, al√©m de que eventualmente n√≥s podemos querer acrescentar mais funcionalidades, portando, mais c√≥digo ao nosso projeto. \nPara uma melhor manuten√ß√£o √© importante separarmos aquilo que √© de inicializa√ß√£o/configura√ß√£o do servidor do que √© funcionalidade para o usu√°rio.\nEnt√£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara come√ßar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os m√≥dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a vari√°vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 m√©todos, index, show, create, update e delete, todos com os mesmo par√¢metros, request e  response, e ao final exportaremos a classe como um m√≥dulo.\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO pr√≥ximo passo para organizarmos nosso c√≥digo √© mover algumas partes de c√≥digo que est√£o no **server.js** para este arquivo. Portanto, todo o c√≥digo dentro de `app.get('/', (request, response){...})` ficar√° dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usu√°rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nO mesmo ser√° feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora n√£o est√° se comunicando com o servidor/Express e para deixar nosso c√≥digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diret√≥rio do arquivo **server.js**. Este arquivo ir√° conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um m√≥dulo, usando **./controllers/FactsController** para sinalizar que √© um m√≥dulo criado no projeto. Importaremos tamb√©m o m√≥dulo Express, por√©m, dessa vez iniciaremos um roteador, e n√£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um m√≥dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos c√≥digos que n√£o est√£o mais sendo usados pelo servidor. Ent√£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja f√°cil a manuten√ß√£o, ainda n√£o √© o ideal, mas √© o suficiente!\n\nSe voc√™ chegou at√© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu pr√≥prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma s√©rie de posts envolvendo o desenvolvimento de aplica√ß√µes Back End e Front End.\n\nDeixe seu coment√°rio dizendo o que est√° bom e o que √© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":[{"title":"PostgreSQL + Docker = üíô","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, con...","content":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta pr√°tica de conteineriza√ß√£o possibilita uma configura√ß√£o r√°pida de ambientes de desenvolvimento, testes e produ√ß√£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta gr√°fica de administra√ß√£o que, por sua vez, tamb√©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar v√°rios cont√™ineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSer√° demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar cont√™ineres a partir de imagens](#clock4-criar-cont√™ineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, √© esperado que voc√™ tenha conhecimento b√°sico das tecnologias citadas. Certifique-se de que h√° instalado em sua m√°quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial s√£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) s√£o pontes de comunica√ß√£o que possiblitam √† cont√™ineres uma conex√£o entre eles. Geralmente, criasse uma network quando dois ou mias cont√™ineres t√™m uma rela√ß√£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que ser√° utilizada nesse tutorial, √© poss√≠vel ver quais outras networks est√£o sendo utilizadas em sua m√°quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume √© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o cont√™iner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso ser√° criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua m√°quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar cont√™ineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar √© preciso se atentar √† alguns detalhes:\n  \n- Imagens docker s√£o constru√≠das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tamb√©m t√™m uma vers√£o, geralmente estes s√£o vers√µes do pr√≥prio produto/servi√ßo escolhido, e caso n√£o seja especificado uma vers√£o sempre ser√° instalado a √∫ltima vers√£o est√°vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial ser√° usado a imagem do PostgreSQL vers√£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 voc√™ ir√° usar a √∫ltima vers√£o est√°vel (mais abaixo). Siga o comando a baixo para criar um cont√™iner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta √∫nica linha foi criado e executado um cont√™iner, em que:\n  \n- **-\\-name**, especificao nome do cont√™iner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a vari√°vel de ambiente do cont√™iner\n  - **POSTGRES_PASSWORD=postgresql**, √© a vari√°vel de ambiente que especificaa senha necess√°ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta ser√° exposta (**5440:5432**), ou seja, ser√° acess√≠vel de fora do docker (utilizar em uma aplica√ß√£o n√£o conteinerizada).\n- **-d**, especificaque ap√≥s criado o cont√™iner seu terminal se separe do cont√™iner e voc√™ consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o cont√™iner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o cont√™iner, neste caso a image **postgres**, vers√£o **12.4** utilizando linux **alpine**.\n  \n√â poss√≠vel ver outras vers√µes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um cont√™iner utilizando a imagem do pgAdmin4 em sua √∫ltima vers√£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando √© muito parecido com o utilizado para criar o cont√™iner do Postgres. Est√£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de vari√°veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTamb√©m, por √∫ltimo se encontra o nome da imagem utilizada para criar o cont√™iner (**dpage/pgadmin4**), como pode ver, desta vez n√£o foi passado nenhuma vers√£o especifica, portanto, por padr√£o √© instalado a √∫ltima vers√£o est√°vel da imagem, outro jeito de especificar a √∫ltima vers√£o da imagem √© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJ√° que foi criado os dois cont√™ineres √© hora de testar se tudo est√° funcionando como esperado. Primeiro rode o comando abaixo para listar todos os cont√™ineres em execu√ß√£o em sua m√°quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois cont√™ineres ainda estejam em execu√ß√£o voc√™ deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.s‚Ä¶\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta √© a mesma exposta na cria√ß√£o do cont√™iner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"P√°gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como vari√°veis de ambiente na cria√ß√£o do cont√™iner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVoc√™ ser√° redirecionado para outra p√°gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"P√°gina inicial pgadmin\" width=\"384px\"/>\n  \nPor√©m, ainda n√£o h√° nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o bot√£o direito em cima do \"Servers\" no canto superior esquerdo, v√° em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal ser√° aberto onde voc√™ ir√° inserir informa√ß√µes sobre o servidor. No campo \"name\" adicione um nome de sua prefer√™ncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do cont√™iner \"**postgres**\" (nome do cont√™iner Postgres).\n- No campo \"Port\" utilize a porta interna do cont√™iner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como est√°.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como vari√°vel de ambiente na cria√ß√£o do cont√™iner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no bot√£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVer√° que o servidor foi criado e agora voc√™ tem acesso ao banco de dados do mesmo modo se n√£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados √© o nome do cont√™iner (**postgres**) e a porta √© a interna (**5432**). J√° para acesso externo, como em uma aplica√ß√£o feita em NodeJS, o host √© \"**localhost**\" ou \"**127.0.0.1**\" e a porta √© a porta externa especificada na cria√ß√£o do cont√™iner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de cria√ß√£o dos cont√™ineres pode ser feito utilizando um arquivo que por conven√ß√£o/padr√£o √© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, al√©m disso adiciona o conceito de **stack**.\n  \nStack nada mais √© que um conjunto de cont√™ineres que tem uma rela√ß√£o entre si, voc√™ pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack ser√° o nome da pasta em que o arquivo est√°. Ao criar uma network dentro de uma stack o nome desta network ter√° como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para come√ßar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack ser√° **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua prefer√™ncia e comece adicionando o b√°sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que h√°:\n  \n- **version** - vers√£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, ser√° nomeada **postgres-network**, pois ser√° adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do cont√™iner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma √∫nica linha, ser√° criado um cont√™iner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora √© a vez de reescrever script do cont√™iner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTamb√©m, como no cont√™iner **postgres**, est√° tudo bem parecido com escrito anteriormente utilizando uma √∫nica linha. O nome, email, senha, porta e network continuam o mesmo, por√©m tamb√©m foi adicionado um atributo novo, **depends_on**, este permite que o cont√™iner **pgadmin** n√£o seja criado/iniciado antes do cont√™iner **postgres** ser criado/iniciado.\n  \nPor√©m, antes de executar o arquivo ser√° necess√°rio deletar os cont√™ineres j√° existente afinal n√£o ser√£o mais utilizados como anteriormente, agora eles pertecer√£o √† uma stack. Primeiro pare os dois cont√™ineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os cont√™ineres configurados no arquivo sejam criandos, caso ainda n√£o exista, e os execute. Ainda, quando algo for alterado no arquivo os cont√™ineres afetados ser√£o reconstruidos.\n  \nEm algum momento, caso voc√™ queira parar todos os cont√™ineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, j√° ter um arquivo/script de instala√ß√£o econimiza bastante tempo, afinal n√£o √© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na m√£o.\n  \n> O pregui√ßoso sempre arruma um jeito de n√£o ter trabalho.\n  \nPor fim, agrade√ßo voc√™ por ter chegado at√© aqui, deixe seu coment√°rio e sugest√£o para os pr√≥ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":["[Circular ~.1]",{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, √© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo s√£o listados alguns dos conhecimentos que ser√£o descritos e ensinados neste tutorial:\n\n- Boas pr√°ticas de programa√ß√£o\n- Defini√ß√£o de um sistema de pastas simples e eficiente\n- Iniciar um reposit√≥rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de come√ßar √© preciso certificar-se de que alguns programas est√£o instalados na m√°quina que ser√° utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execu√ß√£o de c√≥digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de c√≥digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de c√≥digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisi√ß√µes HTTP.\n\n√â necess√°rio criar uma conta criada no [GitHub](https://github.com/). O GitHub √© a plataforma de hospedagem de c√≥digo-fonte e possui controle de vers√£o. Essa plataforma poder√° auxiliar no transporte do c√≥digo para outro lugar, como para a faculdade ou trabalho.\n\n√â importante saber o que √© um servidor REST, o que √© HTTP e como utilizar o Insomnia para fazer requisi√ß√µes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que est√° sendo montado:\n\n- [O que √© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (v√≠deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir s√£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conte√∫dos\n- [Criando pastas](#criando-pastas)\n- [Criando um reposit√≥rio utilizando GitHub](#criando-um-reposit√≥rio-utilizando-github)\n- [Criando um reposit√≥rio sem GitHub](#criando-um-reposit√≥rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [Dom√≠nio](#dom√≠nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [Cabe√ßalhos](#cabe√ßalhos)\n\t\t- [M√©todos](#m√©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [Par√¢metros (Query String)](#par√¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com par√¢metros](#get-com-par√¢metros)\n\t\t- [GET com rota din√¢mica](#get-com-rota-din√¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara come√ßar ser√° criada uma pasta inicial chamada **server_node**. Ap√≥s cri√°-la √© necess√°rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois √© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto s√£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. Por√©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estar√£o os c√≥digos que controlaram as funcionalidade do usu√°rio, e outra chamada **db**. Na pasta db estar√£o todas a informa√ß√£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas √© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os pr√≥ximos passo √© necess√°rio que o diret√≥rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diret√≥rio atual √© **src** dentro de **server_node**. Para voltar diret√≥rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um reposit√≥rio utilizando GitHub\n\nCaso voc√™ tenha uma conta criada no GitHub, [crie um novo reposit√≥rio](https://github.com/new) com nome **server_node**, sem gitignore, licen√ßa e readme.\nLogo ap√≥s criado o reposit√≥rio ir√° aparecer algumas op√ß√µes para iniciar o mesmo. Copie todo o conte√∫do da op√ß√£o **criar um novo reposit√≥rio usando linha de comando**, no meu caso o c√≥digo √© o mostrado abaixo. Cole o conte√∫do no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conte√∫do \"# server_node\"\ngit init # inicia um reposit√≥rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu reposit√≥rio para o GitHub\n```\n\n# Criando um reposit√≥rio sem GitHub\n\nCaso voc√™ n√£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o c√≥digo abaixo para iniciar seu versionamento de c√≥digo local.\n\n```bash\ngit init # inicia reposit√≥rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS √© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descri√ß√£o do projeto\n- version, vers√£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licen√ßa utilizada no projeto\n- private, se este projeto pode ser public√°vel ou n√£o\n- scripts, comandos de execu√ß√£o\n- dependencies, depend√™ncias principais do projeto\n- devdependencies, depend√™ncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na m√£o, √© muito mais f√°cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, ap√≥s executar, ser√° necess√°rio preencher alguns dados, como √© mostrado abaixo.\n\n```bash\nyarn init # inicia reposit√≥rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes s√£o m√≥dulos, c√≥digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome j√° sugere, pacotes principais s√£o m√≥dulos que seu c√≥digo ir√° precisar mesmo quando em produ√ß√£o e pacotes de desenvolvimento s√£o m√≥dulos que voc√™ usar√° apenas quando estiver programando.\nM√≥dulos que usaremos s√£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplica√ß√£o fa√ßa requisi√ß√£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisi√ß√£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada altera√ß√£o no c√≥digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** √© criada, nela est√° todos os pacotes baixados. Ainda, note que cada vez que voc√™ adiciona ou remove um pacote o arquivo **package.json** √© alterado. Isso serve para caso voc√™ precise copiar seu c√≥digo para outra m√°quina, voc√™ n√£o precise copiar a pasta **node_modules** junto, e seja necess√°rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** ser√£o instalados e automaticamente ser√° criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** ser√° o script para executarmos o servidor em desenvolvimento, reiniciando a cada modifica√ß√£o no c√≥digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** ser√° o script que utilizaremos quando quisermos executar nosso servidor em produ√ß√£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e depend√™ncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de come√ßarmos a codar precisamos lembrar de alguns conceitos de requisi√ß√µes HTTP.\nPara fazermos uma requisi√ß√£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o dom√≠nio, a porta, a rota, os cabe√ßalhos (headers), o corpo (body) e os par√¢metros (query string).\n\n## Dom√≠nio\n\nDom√≠nio, de forma bem ampla, √© o nome do servidor, este √© um jeito utilizado para n√£o precisarmos escrever o IP de todo site que quisermos acessar. O dom√≠nio, assim como o IP, √© √∫nico e √© reconhecido por toda a internet. Como exemplo, a Google tem um dom√≠nio global `google.com`\nque por tr√°s est√° um IP `172.217.28.78`.\n\nA √∫nica exce√ß√£o de dom√≠nio e IP que se repete em toda m√°quina √© o local. Toda m√°quina m√°quina consegue se acessar usando o dom√≠nio local `localhost` e IP `127.0.0.1`, portanto uma m√°quina n√£o consegue acessar um aplica√ß√£o de outra m√°quina utilizando o dom√≠nio `localhost`, pois ela tentar√° acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, s√£o conex√µes de cada aplica√ß√£o dentro da nossa m√°quina. Cada aplica√ß√£o utiliza uma ou mais portas para se comunicar com outra aplica√ß√£o, internamente ou n√£o. Em nossa m√°quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padr√£o HTTP utiliza a porta 80, por isso muita das vezes n√£o precisamos explicitamente colocar a porta ao acessar um site.\nFa√ßa o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso voc√™ conseguir√° acessar o site, por√©m no seguindo caso o navegador n√£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, por√©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, √© o caminho em que o usu√°rio faz uma requisi√ß√£o ao servidor.\nSendo assim, um caminho dita qual conte√∫do voc√™ espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a p√°gina de busca do site `/` , j√° no segundo caso pedimos ao servidor do google que nos mostre a p√°gina doodles `/doodles/`.\n\nServidores t√™m a possibilidade tamb√©m de criar rotas din√¢micas, estas s√£o rotas geradas automaticamente para requisi√ß√£o de um dado espec√≠fico mas que o tratamento desse dado √© gen√©rico. Como, buscar dados de um usu√°rio espec√≠fico. O servidor ir√° retornar os dados apenas daquele usu√°rio, por√©m o tratamento no servidor √© gen√©rico, de forma que consiga buscar qualquer usu√°rio dentro do banco de dados.\n\n## Cabe√ßalhos\n\nOs cabe√ßalhos t√™m informa√ß√µes importantes sobre o usu√°rio e tamb√©m sobre o servidor (no retorno).\nNos cabe√ßalhos conseguimos encontrar o m√©todo/verbo da requisi√ß√£o (GET, POST, PUT, DELETE, entre outros), o tipo do conte√∫do da requisi√ß√£o, o tamanho do conte√∫do enviado na requisi√ß√£o, qual aplica√ß√£o fez a requisi√ß√£o, o dom√≠nio em que o usu√°rio est√°, entre outros.\n\n### M√©todos\n\nComo dito antes, nos cabe√ßalhos √© poss√≠vel encontrar o m√©todo/verbo da requisi√ß√£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conte√∫dos do cabe√ßalho, no servidores com **Express** sempre precisamos falar quais m√©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padr√£o utilizam apenas os m√©todos GET e POST, portanto, para utilizar outro m√©todo √© necess√°rio utilizar JavaScript em uma requisi√ß√£o.\n\n#### GET\n\nPor padr√£o √© utilizado quando queremos apenas o retorno de algum dado/p√°gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usu√°rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor, por√©m, desta vez estamos modificando um dado j√° existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo √© um espa√ßo na requisi√ß√£o HTTP onde os dados de um formul√°rio s√£o enviados ao servidor. H√° v√°rios tipos de conte√∫dos que podem ser enviados no corpo, por isso do campo `tipo de cont√©udo` dentro dos cabe√ßalhos.\n\n## Par√¢metros (Query String)\n\nPar√¢metros, como o nome j√° indica, s√£o par√¢metros que passamos junto a rota, geralmente s√£o utilizados como filtros para alguma requisi√ß√£o.\n\nUm exemplo de par√¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um par√¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais par√¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os par√¢metros s√£o utilizados junto ao m√©todo GET, para filtragem de resultados no servidor. Por√©m nada impede de ser usados junto a outro m√©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- M√©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com par√¢metros\n\n- M√©todo: GET\n- Rota: /nomes\n- Par√¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho m√°ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota din√¢mica\n\n- M√©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informa√ß√µes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- M√©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- M√©todo: PUT\n- Rota din√¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- M√©todo: DELETE\n- Rota din√¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso reposit√≥rio, iniciamos o projeto com Yarn, instalamos alguns m√≥dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisi√ß√£o HTTP.\n\nAgora estamos prontos para ir para a pr√≥xima fase, onde realmente colocamos a m√£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de voc√™ ter chegado at√© aqui! Espero que eu tenha lhe passado algum conhecimento. Ent√£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":["[Circular ~.1.suggestions.0]","[Circular ~.1]"]}]},{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, √© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo s√£o listados alguns dos conhecimentos que ser√£o descritos e ensinados neste tutorial:\n\n- Boas pr√°ticas de programa√ß√£o\n- Defini√ß√£o de um sistema de pastas simples e eficiente\n- Iniciar um reposit√≥rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de come√ßar √© preciso certificar-se de que alguns programas est√£o instalados na m√°quina que ser√° utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execu√ß√£o de c√≥digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de c√≥digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de c√≥digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisi√ß√µes HTTP.\n\n√â necess√°rio criar uma conta criada no [GitHub](https://github.com/). O GitHub √© a plataforma de hospedagem de c√≥digo-fonte e possui controle de vers√£o. Essa plataforma poder√° auxiliar no transporte do c√≥digo para outro lugar, como para a faculdade ou trabalho.\n\n√â importante saber o que √© um servidor REST, o que √© HTTP e como utilizar o Insomnia para fazer requisi√ß√µes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que est√° sendo montado:\n\n- [O que √© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (v√≠deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir s√£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conte√∫dos\n- [Criando pastas](#criando-pastas)\n- [Criando um reposit√≥rio utilizando GitHub](#criando-um-reposit√≥rio-utilizando-github)\n- [Criando um reposit√≥rio sem GitHub](#criando-um-reposit√≥rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [Dom√≠nio](#dom√≠nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [Cabe√ßalhos](#cabe√ßalhos)\n\t\t- [M√©todos](#m√©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [Par√¢metros (Query String)](#par√¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com par√¢metros](#get-com-par√¢metros)\n\t\t- [GET com rota din√¢mica](#get-com-rota-din√¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara come√ßar ser√° criada uma pasta inicial chamada **server_node**. Ap√≥s cri√°-la √© necess√°rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois √© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto s√£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. Por√©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estar√£o os c√≥digos que controlaram as funcionalidade do usu√°rio, e outra chamada **db**. Na pasta db estar√£o todas a informa√ß√£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas √© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os pr√≥ximos passo √© necess√°rio que o diret√≥rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diret√≥rio atual √© **src** dentro de **server_node**. Para voltar diret√≥rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um reposit√≥rio utilizando GitHub\n\nCaso voc√™ tenha uma conta criada no GitHub, [crie um novo reposit√≥rio](https://github.com/new) com nome **server_node**, sem gitignore, licen√ßa e readme.\nLogo ap√≥s criado o reposit√≥rio ir√° aparecer algumas op√ß√µes para iniciar o mesmo. Copie todo o conte√∫do da op√ß√£o **criar um novo reposit√≥rio usando linha de comando**, no meu caso o c√≥digo √© o mostrado abaixo. Cole o conte√∫do no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conte√∫do \"# server_node\"\ngit init # inicia um reposit√≥rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu reposit√≥rio para o GitHub\n```\n\n# Criando um reposit√≥rio sem GitHub\n\nCaso voc√™ n√£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o c√≥digo abaixo para iniciar seu versionamento de c√≥digo local.\n\n```bash\ngit init # inicia reposit√≥rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS √© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descri√ß√£o do projeto\n- version, vers√£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licen√ßa utilizada no projeto\n- private, se este projeto pode ser public√°vel ou n√£o\n- scripts, comandos de execu√ß√£o\n- dependencies, depend√™ncias principais do projeto\n- devdependencies, depend√™ncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na m√£o, √© muito mais f√°cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, ap√≥s executar, ser√° necess√°rio preencher alguns dados, como √© mostrado abaixo.\n\n```bash\nyarn init # inicia reposit√≥rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes s√£o m√≥dulos, c√≥digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome j√° sugere, pacotes principais s√£o m√≥dulos que seu c√≥digo ir√° precisar mesmo quando em produ√ß√£o e pacotes de desenvolvimento s√£o m√≥dulos que voc√™ usar√° apenas quando estiver programando.\nM√≥dulos que usaremos s√£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplica√ß√£o fa√ßa requisi√ß√£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisi√ß√£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada altera√ß√£o no c√≥digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** √© criada, nela est√° todos os pacotes baixados. Ainda, note que cada vez que voc√™ adiciona ou remove um pacote o arquivo **package.json** √© alterado. Isso serve para caso voc√™ precise copiar seu c√≥digo para outra m√°quina, voc√™ n√£o precise copiar a pasta **node_modules** junto, e seja necess√°rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** ser√£o instalados e automaticamente ser√° criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** ser√° o script para executarmos o servidor em desenvolvimento, reiniciando a cada modifica√ß√£o no c√≥digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** ser√° o script que utilizaremos quando quisermos executar nosso servidor em produ√ß√£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e depend√™ncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de come√ßarmos a codar precisamos lembrar de alguns conceitos de requisi√ß√µes HTTP.\nPara fazermos uma requisi√ß√£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o dom√≠nio, a porta, a rota, os cabe√ßalhos (headers), o corpo (body) e os par√¢metros (query string).\n\n## Dom√≠nio\n\nDom√≠nio, de forma bem ampla, √© o nome do servidor, este √© um jeito utilizado para n√£o precisarmos escrever o IP de todo site que quisermos acessar. O dom√≠nio, assim como o IP, √© √∫nico e √© reconhecido por toda a internet. Como exemplo, a Google tem um dom√≠nio global `google.com`\nque por tr√°s est√° um IP `172.217.28.78`.\n\nA √∫nica exce√ß√£o de dom√≠nio e IP que se repete em toda m√°quina √© o local. Toda m√°quina m√°quina consegue se acessar usando o dom√≠nio local `localhost` e IP `127.0.0.1`, portanto uma m√°quina n√£o consegue acessar um aplica√ß√£o de outra m√°quina utilizando o dom√≠nio `localhost`, pois ela tentar√° acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, s√£o conex√µes de cada aplica√ß√£o dentro da nossa m√°quina. Cada aplica√ß√£o utiliza uma ou mais portas para se comunicar com outra aplica√ß√£o, internamente ou n√£o. Em nossa m√°quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padr√£o HTTP utiliza a porta 80, por isso muita das vezes n√£o precisamos explicitamente colocar a porta ao acessar um site.\nFa√ßa o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso voc√™ conseguir√° acessar o site, por√©m no seguindo caso o navegador n√£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, por√©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, √© o caminho em que o usu√°rio faz uma requisi√ß√£o ao servidor.\nSendo assim, um caminho dita qual conte√∫do voc√™ espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a p√°gina de busca do site `/` , j√° no segundo caso pedimos ao servidor do google que nos mostre a p√°gina doodles `/doodles/`.\n\nServidores t√™m a possibilidade tamb√©m de criar rotas din√¢micas, estas s√£o rotas geradas automaticamente para requisi√ß√£o de um dado espec√≠fico mas que o tratamento desse dado √© gen√©rico. Como, buscar dados de um usu√°rio espec√≠fico. O servidor ir√° retornar os dados apenas daquele usu√°rio, por√©m o tratamento no servidor √© gen√©rico, de forma que consiga buscar qualquer usu√°rio dentro do banco de dados.\n\n## Cabe√ßalhos\n\nOs cabe√ßalhos t√™m informa√ß√µes importantes sobre o usu√°rio e tamb√©m sobre o servidor (no retorno).\nNos cabe√ßalhos conseguimos encontrar o m√©todo/verbo da requisi√ß√£o (GET, POST, PUT, DELETE, entre outros), o tipo do conte√∫do da requisi√ß√£o, o tamanho do conte√∫do enviado na requisi√ß√£o, qual aplica√ß√£o fez a requisi√ß√£o, o dom√≠nio em que o usu√°rio est√°, entre outros.\n\n### M√©todos\n\nComo dito antes, nos cabe√ßalhos √© poss√≠vel encontrar o m√©todo/verbo da requisi√ß√£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conte√∫dos do cabe√ßalho, no servidores com **Express** sempre precisamos falar quais m√©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padr√£o utilizam apenas os m√©todos GET e POST, portanto, para utilizar outro m√©todo √© necess√°rio utilizar JavaScript em uma requisi√ß√£o.\n\n#### GET\n\nPor padr√£o √© utilizado quando queremos apenas o retorno de algum dado/p√°gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usu√°rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor, por√©m, desta vez estamos modificando um dado j√° existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo √© um espa√ßo na requisi√ß√£o HTTP onde os dados de um formul√°rio s√£o enviados ao servidor. H√° v√°rios tipos de conte√∫dos que podem ser enviados no corpo, por isso do campo `tipo de cont√©udo` dentro dos cabe√ßalhos.\n\n## Par√¢metros (Query String)\n\nPar√¢metros, como o nome j√° indica, s√£o par√¢metros que passamos junto a rota, geralmente s√£o utilizados como filtros para alguma requisi√ß√£o.\n\nUm exemplo de par√¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um par√¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais par√¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os par√¢metros s√£o utilizados junto ao m√©todo GET, para filtragem de resultados no servidor. Por√©m nada impede de ser usados junto a outro m√©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- M√©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com par√¢metros\n\n- M√©todo: GET\n- Rota: /nomes\n- Par√¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho m√°ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota din√¢mica\n\n- M√©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informa√ß√µes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- M√©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- M√©todo: PUT\n- Rota din√¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- M√©todo: DELETE\n- Rota din√¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso reposit√≥rio, iniciamos o projeto com Yarn, instalamos alguns m√≥dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisi√ß√£o HTTP.\n\nAgora estamos prontos para ir para a pr√≥xima fase, onde realmente colocamos a m√£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de voc√™ ter chegado at√© aqui! Espero que eu tenha lhe passado algum conhecimento. Ent√£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":[{"title":"PostgreSQL + Docker = üíô","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, con...","content":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta pr√°tica de conteineriza√ß√£o possibilita uma configura√ß√£o r√°pida de ambientes de desenvolvimento, testes e produ√ß√£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta gr√°fica de administra√ß√£o que, por sua vez, tamb√©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar v√°rios cont√™ineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSer√° demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar cont√™ineres a partir de imagens](#clock4-criar-cont√™ineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, √© esperado que voc√™ tenha conhecimento b√°sico das tecnologias citadas. Certifique-se de que h√° instalado em sua m√°quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial s√£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) s√£o pontes de comunica√ß√£o que possiblitam √† cont√™ineres uma conex√£o entre eles. Geralmente, criasse uma network quando dois ou mias cont√™ineres t√™m uma rela√ß√£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que ser√° utilizada nesse tutorial, √© poss√≠vel ver quais outras networks est√£o sendo utilizadas em sua m√°quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume √© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o cont√™iner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso ser√° criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua m√°quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar cont√™ineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar √© preciso se atentar √† alguns detalhes:\n  \n- Imagens docker s√£o constru√≠das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tamb√©m t√™m uma vers√£o, geralmente estes s√£o vers√µes do pr√≥prio produto/servi√ßo escolhido, e caso n√£o seja especificado uma vers√£o sempre ser√° instalado a √∫ltima vers√£o est√°vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial ser√° usado a imagem do PostgreSQL vers√£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 voc√™ ir√° usar a √∫ltima vers√£o est√°vel (mais abaixo). Siga o comando a baixo para criar um cont√™iner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta √∫nica linha foi criado e executado um cont√™iner, em que:\n  \n- **-\\-name**, especificao nome do cont√™iner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a vari√°vel de ambiente do cont√™iner\n  - **POSTGRES_PASSWORD=postgresql**, √© a vari√°vel de ambiente que especificaa senha necess√°ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta ser√° exposta (**5440:5432**), ou seja, ser√° acess√≠vel de fora do docker (utilizar em uma aplica√ß√£o n√£o conteinerizada).\n- **-d**, especificaque ap√≥s criado o cont√™iner seu terminal se separe do cont√™iner e voc√™ consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o cont√™iner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o cont√™iner, neste caso a image **postgres**, vers√£o **12.4** utilizando linux **alpine**.\n  \n√â poss√≠vel ver outras vers√µes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um cont√™iner utilizando a imagem do pgAdmin4 em sua √∫ltima vers√£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando √© muito parecido com o utilizado para criar o cont√™iner do Postgres. Est√£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de vari√°veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTamb√©m, por √∫ltimo se encontra o nome da imagem utilizada para criar o cont√™iner (**dpage/pgadmin4**), como pode ver, desta vez n√£o foi passado nenhuma vers√£o especifica, portanto, por padr√£o √© instalado a √∫ltima vers√£o est√°vel da imagem, outro jeito de especificar a √∫ltima vers√£o da imagem √© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJ√° que foi criado os dois cont√™ineres √© hora de testar se tudo est√° funcionando como esperado. Primeiro rode o comando abaixo para listar todos os cont√™ineres em execu√ß√£o em sua m√°quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois cont√™ineres ainda estejam em execu√ß√£o voc√™ deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.s‚Ä¶\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta √© a mesma exposta na cria√ß√£o do cont√™iner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"P√°gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como vari√°veis de ambiente na cria√ß√£o do cont√™iner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVoc√™ ser√° redirecionado para outra p√°gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"P√°gina inicial pgadmin\" width=\"384px\"/>\n  \nPor√©m, ainda n√£o h√° nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o bot√£o direito em cima do \"Servers\" no canto superior esquerdo, v√° em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal ser√° aberto onde voc√™ ir√° inserir informa√ß√µes sobre o servidor. No campo \"name\" adicione um nome de sua prefer√™ncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do cont√™iner \"**postgres**\" (nome do cont√™iner Postgres).\n- No campo \"Port\" utilize a porta interna do cont√™iner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como est√°.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como vari√°vel de ambiente na cria√ß√£o do cont√™iner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no bot√£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVer√° que o servidor foi criado e agora voc√™ tem acesso ao banco de dados do mesmo modo se n√£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados √© o nome do cont√™iner (**postgres**) e a porta √© a interna (**5432**). J√° para acesso externo, como em uma aplica√ß√£o feita em NodeJS, o host √© \"**localhost**\" ou \"**127.0.0.1**\" e a porta √© a porta externa especificada na cria√ß√£o do cont√™iner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de cria√ß√£o dos cont√™ineres pode ser feito utilizando um arquivo que por conven√ß√£o/padr√£o √© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, al√©m disso adiciona o conceito de **stack**.\n  \nStack nada mais √© que um conjunto de cont√™ineres que tem uma rela√ß√£o entre si, voc√™ pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack ser√° o nome da pasta em que o arquivo est√°. Ao criar uma network dentro de uma stack o nome desta network ter√° como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para come√ßar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack ser√° **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua prefer√™ncia e comece adicionando o b√°sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que h√°:\n  \n- **version** - vers√£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, ser√° nomeada **postgres-network**, pois ser√° adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do cont√™iner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma √∫nica linha, ser√° criado um cont√™iner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora √© a vez de reescrever script do cont√™iner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTamb√©m, como no cont√™iner **postgres**, est√° tudo bem parecido com escrito anteriormente utilizando uma √∫nica linha. O nome, email, senha, porta e network continuam o mesmo, por√©m tamb√©m foi adicionado um atributo novo, **depends_on**, este permite que o cont√™iner **pgadmin** n√£o seja criado/iniciado antes do cont√™iner **postgres** ser criado/iniciado.\n  \nPor√©m, antes de executar o arquivo ser√° necess√°rio deletar os cont√™ineres j√° existente afinal n√£o ser√£o mais utilizados como anteriormente, agora eles pertecer√£o √† uma stack. Primeiro pare os dois cont√™ineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os cont√™ineres configurados no arquivo sejam criandos, caso ainda n√£o exista, e os execute. Ainda, quando algo for alterado no arquivo os cont√™ineres afetados ser√£o reconstruidos.\n  \nEm algum momento, caso voc√™ queira parar todos os cont√™ineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, j√° ter um arquivo/script de instala√ß√£o econimiza bastante tempo, afinal n√£o √© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na m√£o.\n  \n> O pregui√ßoso sempre arruma um jeito de n√£o ter trabalho.\n  \nPor fim, agrade√ßo voc√™ por ter chegado at√© aqui, deixe seu coment√°rio e sugest√£o para os pr√≥ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":["[Circular ~.1]","[Circular ~.1.suggestions.1]"]},"[Circular ~.1]"]}]},{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, √© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo s√£o listados alguns dos conhecimentos que ser√£o descritos e ensinados neste tutorial:\n\n- Boas pr√°ticas de programa√ß√£o\n- Defini√ß√£o de um sistema de pastas simples e eficiente\n- Iniciar um reposit√≥rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de come√ßar √© preciso certificar-se de que alguns programas est√£o instalados na m√°quina que ser√° utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execu√ß√£o de c√≥digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de c√≥digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de c√≥digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisi√ß√µes HTTP.\n\n√â necess√°rio criar uma conta criada no [GitHub](https://github.com/). O GitHub √© a plataforma de hospedagem de c√≥digo-fonte e possui controle de vers√£o. Essa plataforma poder√° auxiliar no transporte do c√≥digo para outro lugar, como para a faculdade ou trabalho.\n\n√â importante saber o que √© um servidor REST, o que √© HTTP e como utilizar o Insomnia para fazer requisi√ß√µes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que est√° sendo montado:\n\n- [O que √© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (v√≠deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir s√£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conte√∫dos\n- [Criando pastas](#criando-pastas)\n- [Criando um reposit√≥rio utilizando GitHub](#criando-um-reposit√≥rio-utilizando-github)\n- [Criando um reposit√≥rio sem GitHub](#criando-um-reposit√≥rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [Dom√≠nio](#dom√≠nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [Cabe√ßalhos](#cabe√ßalhos)\n\t\t- [M√©todos](#m√©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [Par√¢metros (Query String)](#par√¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com par√¢metros](#get-com-par√¢metros)\n\t\t- [GET com rota din√¢mica](#get-com-rota-din√¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara come√ßar ser√° criada uma pasta inicial chamada **server_node**. Ap√≥s cri√°-la √© necess√°rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois √© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto s√£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. Por√©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estar√£o os c√≥digos que controlaram as funcionalidade do usu√°rio, e outra chamada **db**. Na pasta db estar√£o todas a informa√ß√£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas √© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os pr√≥ximos passo √© necess√°rio que o diret√≥rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diret√≥rio atual √© **src** dentro de **server_node**. Para voltar diret√≥rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um reposit√≥rio utilizando GitHub\n\nCaso voc√™ tenha uma conta criada no GitHub, [crie um novo reposit√≥rio](https://github.com/new) com nome **server_node**, sem gitignore, licen√ßa e readme.\nLogo ap√≥s criado o reposit√≥rio ir√° aparecer algumas op√ß√µes para iniciar o mesmo. Copie todo o conte√∫do da op√ß√£o **criar um novo reposit√≥rio usando linha de comando**, no meu caso o c√≥digo √© o mostrado abaixo. Cole o conte√∫do no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conte√∫do \"# server_node\"\ngit init # inicia um reposit√≥rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu reposit√≥rio para o GitHub\n```\n\n# Criando um reposit√≥rio sem GitHub\n\nCaso voc√™ n√£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o c√≥digo abaixo para iniciar seu versionamento de c√≥digo local.\n\n```bash\ngit init # inicia reposit√≥rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS √© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descri√ß√£o do projeto\n- version, vers√£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licen√ßa utilizada no projeto\n- private, se este projeto pode ser public√°vel ou n√£o\n- scripts, comandos de execu√ß√£o\n- dependencies, depend√™ncias principais do projeto\n- devdependencies, depend√™ncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na m√£o, √© muito mais f√°cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, ap√≥s executar, ser√° necess√°rio preencher alguns dados, como √© mostrado abaixo.\n\n```bash\nyarn init # inicia reposit√≥rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes s√£o m√≥dulos, c√≥digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome j√° sugere, pacotes principais s√£o m√≥dulos que seu c√≥digo ir√° precisar mesmo quando em produ√ß√£o e pacotes de desenvolvimento s√£o m√≥dulos que voc√™ usar√° apenas quando estiver programando.\nM√≥dulos que usaremos s√£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplica√ß√£o fa√ßa requisi√ß√£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisi√ß√£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada altera√ß√£o no c√≥digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** √© criada, nela est√° todos os pacotes baixados. Ainda, note que cada vez que voc√™ adiciona ou remove um pacote o arquivo **package.json** √© alterado. Isso serve para caso voc√™ precise copiar seu c√≥digo para outra m√°quina, voc√™ n√£o precise copiar a pasta **node_modules** junto, e seja necess√°rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** ser√£o instalados e automaticamente ser√° criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** ser√° o script para executarmos o servidor em desenvolvimento, reiniciando a cada modifica√ß√£o no c√≥digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** ser√° o script que utilizaremos quando quisermos executar nosso servidor em produ√ß√£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e depend√™ncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de come√ßarmos a codar precisamos lembrar de alguns conceitos de requisi√ß√µes HTTP.\nPara fazermos uma requisi√ß√£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o dom√≠nio, a porta, a rota, os cabe√ßalhos (headers), o corpo (body) e os par√¢metros (query string).\n\n## Dom√≠nio\n\nDom√≠nio, de forma bem ampla, √© o nome do servidor, este √© um jeito utilizado para n√£o precisarmos escrever o IP de todo site que quisermos acessar. O dom√≠nio, assim como o IP, √© √∫nico e √© reconhecido por toda a internet. Como exemplo, a Google tem um dom√≠nio global `google.com`\nque por tr√°s est√° um IP `172.217.28.78`.\n\nA √∫nica exce√ß√£o de dom√≠nio e IP que se repete em toda m√°quina √© o local. Toda m√°quina m√°quina consegue se acessar usando o dom√≠nio local `localhost` e IP `127.0.0.1`, portanto uma m√°quina n√£o consegue acessar um aplica√ß√£o de outra m√°quina utilizando o dom√≠nio `localhost`, pois ela tentar√° acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, s√£o conex√µes de cada aplica√ß√£o dentro da nossa m√°quina. Cada aplica√ß√£o utiliza uma ou mais portas para se comunicar com outra aplica√ß√£o, internamente ou n√£o. Em nossa m√°quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padr√£o HTTP utiliza a porta 80, por isso muita das vezes n√£o precisamos explicitamente colocar a porta ao acessar um site.\nFa√ßa o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso voc√™ conseguir√° acessar o site, por√©m no seguindo caso o navegador n√£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, por√©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, √© o caminho em que o usu√°rio faz uma requisi√ß√£o ao servidor.\nSendo assim, um caminho dita qual conte√∫do voc√™ espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a p√°gina de busca do site `/` , j√° no segundo caso pedimos ao servidor do google que nos mostre a p√°gina doodles `/doodles/`.\n\nServidores t√™m a possibilidade tamb√©m de criar rotas din√¢micas, estas s√£o rotas geradas automaticamente para requisi√ß√£o de um dado espec√≠fico mas que o tratamento desse dado √© gen√©rico. Como, buscar dados de um usu√°rio espec√≠fico. O servidor ir√° retornar os dados apenas daquele usu√°rio, por√©m o tratamento no servidor √© gen√©rico, de forma que consiga buscar qualquer usu√°rio dentro do banco de dados.\n\n## Cabe√ßalhos\n\nOs cabe√ßalhos t√™m informa√ß√µes importantes sobre o usu√°rio e tamb√©m sobre o servidor (no retorno).\nNos cabe√ßalhos conseguimos encontrar o m√©todo/verbo da requisi√ß√£o (GET, POST, PUT, DELETE, entre outros), o tipo do conte√∫do da requisi√ß√£o, o tamanho do conte√∫do enviado na requisi√ß√£o, qual aplica√ß√£o fez a requisi√ß√£o, o dom√≠nio em que o usu√°rio est√°, entre outros.\n\n### M√©todos\n\nComo dito antes, nos cabe√ßalhos √© poss√≠vel encontrar o m√©todo/verbo da requisi√ß√£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conte√∫dos do cabe√ßalho, no servidores com **Express** sempre precisamos falar quais m√©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padr√£o utilizam apenas os m√©todos GET e POST, portanto, para utilizar outro m√©todo √© necess√°rio utilizar JavaScript em uma requisi√ß√£o.\n\n#### GET\n\nPor padr√£o √© utilizado quando queremos apenas o retorno de algum dado/p√°gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usu√°rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formul√°rio para servidor, por√©m, desta vez estamos modificando um dado j√° existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo √© um espa√ßo na requisi√ß√£o HTTP onde os dados de um formul√°rio s√£o enviados ao servidor. H√° v√°rios tipos de conte√∫dos que podem ser enviados no corpo, por isso do campo `tipo de cont√©udo` dentro dos cabe√ßalhos.\n\n## Par√¢metros (Query String)\n\nPar√¢metros, como o nome j√° indica, s√£o par√¢metros que passamos junto a rota, geralmente s√£o utilizados como filtros para alguma requisi√ß√£o.\n\nUm exemplo de par√¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um par√¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais par√¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os par√¢metros s√£o utilizados junto ao m√©todo GET, para filtragem de resultados no servidor. Por√©m nada impede de ser usados junto a outro m√©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- M√©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com par√¢metros\n\n- M√©todo: GET\n- Rota: /nomes\n- Par√¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho m√°ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota din√¢mica\n\n- M√©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informa√ß√µes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- M√©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- M√©todo: PUT\n- Rota din√¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- M√©todo: DELETE\n- Rota din√¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota din√¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso reposit√≥rio, iniciamos o projeto com Yarn, instalamos alguns m√≥dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisi√ß√£o HTTP.\n\nAgora estamos prontos para ir para a pr√≥xima fase, onde realmente colocamos a m√£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de voc√™ ter chegado at√© aqui! Espero que eu tenha lhe passado algum conhecimento. Ent√£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":[{"title":"PostgreSQL + Docker = üíô","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, con...","content":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta pr√°tica de conteineriza√ß√£o possibilita uma configura√ß√£o r√°pida de ambientes de desenvolvimento, testes e produ√ß√£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta gr√°fica de administra√ß√£o que, por sua vez, tamb√©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar v√°rios cont√™ineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSer√° demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar cont√™ineres a partir de imagens](#clock4-criar-cont√™ineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, √© esperado que voc√™ tenha conhecimento b√°sico das tecnologias citadas. Certifique-se de que h√° instalado em sua m√°quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial s√£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) s√£o pontes de comunica√ß√£o que possiblitam √† cont√™ineres uma conex√£o entre eles. Geralmente, criasse uma network quando dois ou mias cont√™ineres t√™m uma rela√ß√£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que ser√° utilizada nesse tutorial, √© poss√≠vel ver quais outras networks est√£o sendo utilizadas em sua m√°quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume √© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o cont√™iner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso ser√° criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua m√°quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar cont√™ineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar √© preciso se atentar √† alguns detalhes:\n  \n- Imagens docker s√£o constru√≠das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tamb√©m t√™m uma vers√£o, geralmente estes s√£o vers√µes do pr√≥prio produto/servi√ßo escolhido, e caso n√£o seja especificado uma vers√£o sempre ser√° instalado a √∫ltima vers√£o est√°vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial ser√° usado a imagem do PostgreSQL vers√£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 voc√™ ir√° usar a √∫ltima vers√£o est√°vel (mais abaixo). Siga o comando a baixo para criar um cont√™iner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta √∫nica linha foi criado e executado um cont√™iner, em que:\n  \n- **-\\-name**, especificao nome do cont√™iner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a vari√°vel de ambiente do cont√™iner\n  - **POSTGRES_PASSWORD=postgresql**, √© a vari√°vel de ambiente que especificaa senha necess√°ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta ser√° exposta (**5440:5432**), ou seja, ser√° acess√≠vel de fora do docker (utilizar em uma aplica√ß√£o n√£o conteinerizada).\n- **-d**, especificaque ap√≥s criado o cont√™iner seu terminal se separe do cont√™iner e voc√™ consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o cont√™iner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o cont√™iner, neste caso a image **postgres**, vers√£o **12.4** utilizando linux **alpine**.\n  \n√â poss√≠vel ver outras vers√µes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um cont√™iner utilizando a imagem do pgAdmin4 em sua √∫ltima vers√£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando √© muito parecido com o utilizado para criar o cont√™iner do Postgres. Est√£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de vari√°veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTamb√©m, por √∫ltimo se encontra o nome da imagem utilizada para criar o cont√™iner (**dpage/pgadmin4**), como pode ver, desta vez n√£o foi passado nenhuma vers√£o especifica, portanto, por padr√£o √© instalado a √∫ltima vers√£o est√°vel da imagem, outro jeito de especificar a √∫ltima vers√£o da imagem √© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJ√° que foi criado os dois cont√™ineres √© hora de testar se tudo est√° funcionando como esperado. Primeiro rode o comando abaixo para listar todos os cont√™ineres em execu√ß√£o em sua m√°quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois cont√™ineres ainda estejam em execu√ß√£o voc√™ deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.s‚Ä¶\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta √© a mesma exposta na cria√ß√£o do cont√™iner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"P√°gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como vari√°veis de ambiente na cria√ß√£o do cont√™iner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVoc√™ ser√° redirecionado para outra p√°gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"P√°gina inicial pgadmin\" width=\"384px\"/>\n  \nPor√©m, ainda n√£o h√° nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o bot√£o direito em cima do \"Servers\" no canto superior esquerdo, v√° em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal ser√° aberto onde voc√™ ir√° inserir informa√ß√µes sobre o servidor. No campo \"name\" adicione um nome de sua prefer√™ncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do cont√™iner \"**postgres**\" (nome do cont√™iner Postgres).\n- No campo \"Port\" utilize a porta interna do cont√™iner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como est√°.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como vari√°vel de ambiente na cria√ß√£o do cont√™iner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no bot√£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVer√° que o servidor foi criado e agora voc√™ tem acesso ao banco de dados do mesmo modo se n√£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados √© o nome do cont√™iner (**postgres**) e a porta √© a interna (**5432**). J√° para acesso externo, como em uma aplica√ß√£o feita em NodeJS, o host √© \"**localhost**\" ou \"**127.0.0.1**\" e a porta √© a porta externa especificada na cria√ß√£o do cont√™iner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de cria√ß√£o dos cont√™ineres pode ser feito utilizando um arquivo que por conven√ß√£o/padr√£o √© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, al√©m disso adiciona o conceito de **stack**.\n  \nStack nada mais √© que um conjunto de cont√™ineres que tem uma rela√ß√£o entre si, voc√™ pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack ser√° o nome da pasta em que o arquivo est√°. Ao criar uma network dentro de uma stack o nome desta network ter√° como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para come√ßar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack ser√° **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua prefer√™ncia e comece adicionando o b√°sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que h√°:\n  \n- **version** - vers√£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, ser√° nomeada **postgres-network**, pois ser√° adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do cont√™iner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma √∫nica linha, ser√° criado um cont√™iner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora √© a vez de reescrever script do cont√™iner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTamb√©m, como no cont√™iner **postgres**, est√° tudo bem parecido com escrito anteriormente utilizando uma √∫nica linha. O nome, email, senha, porta e network continuam o mesmo, por√©m tamb√©m foi adicionado um atributo novo, **depends_on**, este permite que o cont√™iner **pgadmin** n√£o seja criado/iniciado antes do cont√™iner **postgres** ser criado/iniciado.\n  \nPor√©m, antes de executar o arquivo ser√° necess√°rio deletar os cont√™ineres j√° existente afinal n√£o ser√£o mais utilizados como anteriormente, agora eles pertecer√£o √† uma stack. Primeiro pare os dois cont√™ineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os cont√™ineres configurados no arquivo sejam criandos, caso ainda n√£o exista, e os execute. Ainda, quando algo for alterado no arquivo os cont√™ineres afetados ser√£o reconstruidos.\n  \nEm algum momento, caso voc√™ queira parar todos os cont√™ineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, j√° ter um arquivo/script de instala√ß√£o econimiza bastante tempo, afinal n√£o √© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na m√£o.\n  \n> O pregui√ßoso sempre arruma um jeito de n√£o ter trabalho.\n  \nPor fim, agrade√ßo voc√™ por ter chegado at√© aqui, deixe seu coment√°rio e sugest√£o para os pr√≥ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":[{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso voc√™ n√£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conte√∫dos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a m√£o na massa](#botando-a-m√£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [Reorganiza√ß√£o de c√≥digo](#reorganiza√ß√£o-de-c√≥digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada altera√ß√£o importante no c√≥digo fazer um commit. Isso permite que caso algo d√™ errado seja poss√≠vel recuperar a √∫ltima vers√£o correta do c√≥digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJ√° temos nossa organiza√ß√£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e come√ßarmos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de c√≥digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o pr√≥ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a m√£o na massa\nCom a pasta **server_node** aberta no VS Code como diret√≥rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora √© preciso apenas come√ßar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma vari√°vel, no nosso caso **app**,  como uma fun√ß√£o.\n\nAgora, diga ao **app** escutar requisi√ß√µes na porta 3000, como est√° abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui √† app como uma fun√ß√£o\nconst app = express()\n\n// inicia servidor escutando requisi√ß√µes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente come√ßou, temos um servidor que escuta na porta 3000 da nossa m√°quina, por√©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplica√ß√µes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requi√ß√£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisi√ß√µes HTTP\n - falamos para o app/express utilizar o cors em sua execu√ß√£o\n - falamos para o app/express utilizar o morgan em sua execu√ß√£o\n - finalmente, criamos uma rota com o m√©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o b√°sico b√°sico de um servidor em node, por√©m at√© agora n√£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor √© um programa que fica sempre em execu√ß√£o, apenas interrompido quando h√° algum erro ou outro programa/usu√°rio for√ßa sua interrup√ß√£o, ele ficar√° esperando requisi√ß√µes. Portanto, fa√ßa uma requisi√ß√£o, pelo pr√≥prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, voc√™ receber√° um **ok** na p√°gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, por√©m tamb√©m n√£o se reinicia quando fizermos alguma altera√ß√£o no c√≥digo, para isso preparamos o script **dev**. Portanto, interrompa a execu√ß√£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJ√° que programamos nossa primeira rota, √© hora de realmente retornar ao usu√°rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois m√≥dulos padr√µes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, prov√™ m√©todos para facilmente trabalhar com caminhos dentro do node\n- fs, prov√™ m√©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na vari√°vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o m√©todo **readFileSync** do m√≥dulo **fs** (sempre retorna string)\n - Fazemos o parse/transforma√ß√£o da string para o formato json\n - Retornamos o json para o usu√°rio\n\n√â pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // L√™ de forma s√≠ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usu√°rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto √© poss√≠vel ver como funciona um servidor API Rest, o usu√°rio faz uma requisi√ß√£o e o retorno √© apenas em json, nada de HTML.\n\nNosso c√≥digo est√° bem enxuto, e queremos isto, algo simples, de f√°cil entendimento, por√©m que resolva o proposto. Por√©m, n√£o estamos tratando nenhuma exce√ß√£o ou erro que possa acontecer durante a execu√ß√£o.\n\nPara resolver esse problema vamos envolver todo o conte√∫do dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usu√°rio. Mas ainda n√£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usu√°rio de c√≥digo 200, e caso d√™ algum problema durante a execu√ß√£o do nosso c√≥digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usu√°rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execu√ß√£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento j√° estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. Ent√£o, no pr√≥ximo criaremos a leitura de um dado apenas, baseado na rota que o usu√°rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os m√©todo GET novamente, por√©m, utilizaremos uma rota din√¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este n√∫mero adicional na rota nos dar√° a capacidade de retornarmos ao usu√°rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisi√ß√£o do usu√°rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisi√ß√µes com metodo GET com um par√¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisi√ß√£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma vari√°vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a vari√°vel n√£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usu√°rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nTemos as duas requisi√ß√µes com o m√©todo GET, para quando o usu√°rio pedir todos os fatos e quando pedir apenas um fato com um espec√≠fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usu√°rio seja capaz de criar um novo fato. \nNo corpo da requisi√ß√£o pegaremos todos os campos necess√°rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade √©:\n- ouvir requisi√ß√µes com o m√©todo POST\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto com as propriedades necess√°rias, id, text, type e upvotes\n- adicionar o novo fato √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com metodo POST\napp.post('/', (request, response) => {\n\t// l√™ o campo text do corpo da requisi√ß√£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usu√°rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n### ALTERAR\nJ√° que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usu√°rio altere algum fato em nosso arquivo/banco a partir da rota din√¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez √©:\n- ouvir requisi√ß√µes com o m√©todo PUT e ID\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com m√©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisi√ß√£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas vari√°veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// vari√°vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usu√°rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da altera√ß√£o, precisando do ID da rota, por√©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, √©:\n- ouvir requisi√ß√µes com o m√©todo DELETE e ID\n- ler arquivo e guardar em uma vari√°vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com o m√©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma vari√°vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o √≠ndice do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do √≠ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n\n# Reorganiza√ß√£o de c√≥digo\n## Criando controller\nSe voc√™ olhar para seu arquivo **server.js**  ele est√° enorme e √© dif√≠cil sua leitura, al√©m de que eventualmente n√≥s podemos querer acrescentar mais funcionalidades, portando, mais c√≥digo ao nosso projeto. \nPara uma melhor manuten√ß√£o √© importante separarmos aquilo que √© de inicializa√ß√£o/configura√ß√£o do servidor do que √© funcionalidade para o usu√°rio.\nEnt√£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara come√ßar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os m√≥dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a vari√°vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 m√©todos, index, show, create, update e delete, todos com os mesmo par√¢metros, request e  response, e ao final exportaremos a classe como um m√≥dulo.\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO pr√≥ximo passo para organizarmos nosso c√≥digo √© mover algumas partes de c√≥digo que est√£o no **server.js** para este arquivo. Portanto, todo o c√≥digo dentro de `app.get('/', (request, response){...})` ficar√° dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usu√°rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nO mesmo ser√° feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora n√£o est√° se comunicando com o servidor/Express e para deixar nosso c√≥digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diret√≥rio do arquivo **server.js**. Este arquivo ir√° conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um m√≥dulo, usando **./controllers/FactsController** para sinalizar que √© um m√≥dulo criado no projeto. Importaremos tamb√©m o m√≥dulo Express, por√©m, dessa vez iniciaremos um roteador, e n√£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um m√≥dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos c√≥digos que n√£o est√£o mais sendo usados pelo servidor. Ent√£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja f√°cil a manuten√ß√£o, ainda n√£o √© o ideal, mas √© o suficiente!\n\nSe voc√™ chegou at√© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu pr√≥prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma s√©rie de posts envolvendo o desenvolvimento de aplica√ß√µes Back End e Front End.\n\nDeixe seu coment√°rio dizendo o que est√° bom e o que √© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":["[Circular ~.2.suggestions.0]","[Circular ~.2]"]},"[Circular ~.2]"]},{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta √© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso voc√™ n√£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> Reposit√≥rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conte√∫dos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a m√£o na massa](#botando-a-m√£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [Reorganiza√ß√£o de c√≥digo](#reorganiza√ß√£o-de-c√≥digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada altera√ß√£o importante no c√≥digo fazer um commit. Isso permite que caso algo d√™ errado seja poss√≠vel recuperar a √∫ltima vers√£o correta do c√≥digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJ√° temos nossa organiza√ß√£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e come√ßarmos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de c√≥digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o pr√≥ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a m√£o na massa\nCom a pasta **server_node** aberta no VS Code como diret√≥rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora √© preciso apenas come√ßar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma vari√°vel, no nosso caso **app**,  como uma fun√ß√£o.\n\nAgora, diga ao **app** escutar requisi√ß√µes na porta 3000, como est√° abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui √† app como uma fun√ß√£o\nconst app = express()\n\n// inicia servidor escutando requisi√ß√µes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente come√ßou, temos um servidor que escuta na porta 3000 da nossa m√°quina, por√©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplica√ß√µes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requi√ß√£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisi√ß√µes HTTP\n - falamos para o app/express utilizar o cors em sua execu√ß√£o\n - falamos para o app/express utilizar o morgan em sua execu√ß√£o\n - finalmente, criamos uma rota com o m√©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o b√°sico b√°sico de um servidor em node, por√©m at√© agora n√£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor √© um programa que fica sempre em execu√ß√£o, apenas interrompido quando h√° algum erro ou outro programa/usu√°rio for√ßa sua interrup√ß√£o, ele ficar√° esperando requisi√ß√µes. Portanto, fa√ßa uma requisi√ß√£o, pelo pr√≥prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, voc√™ receber√° um **ok** na p√°gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, por√©m tamb√©m n√£o se reinicia quando fizermos alguma altera√ß√£o no c√≥digo, para isso preparamos o script **dev**. Portanto, interrompa a execu√ß√£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJ√° que programamos nossa primeira rota, √© hora de realmente retornar ao usu√°rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois m√≥dulos padr√µes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, prov√™ m√©todos para facilmente trabalhar com caminhos dentro do node\n- fs, prov√™ m√©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na vari√°vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o m√©todo **readFileSync** do m√≥dulo **fs** (sempre retorna string)\n - Fazemos o parse/transforma√ß√£o da string para o formato json\n - Retornamos o json para o usu√°rio\n\n√â pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // L√™ de forma s√≠ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usu√°rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto √© poss√≠vel ver como funciona um servidor API Rest, o usu√°rio faz uma requisi√ß√£o e o retorno √© apenas em json, nada de HTML.\n\nNosso c√≥digo est√° bem enxuto, e queremos isto, algo simples, de f√°cil entendimento, por√©m que resolva o proposto. Por√©m, n√£o estamos tratando nenhuma exce√ß√£o ou erro que possa acontecer durante a execu√ß√£o.\n\nPara resolver esse problema vamos envolver todo o conte√∫do dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usu√°rio. Mas ainda n√£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usu√°rio de c√≥digo 200, e caso d√™ algum problema durante a execu√ß√£o do nosso c√≥digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usu√°rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usu√°rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execu√ß√£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento j√° estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. Ent√£o, no pr√≥ximo criaremos a leitura de um dado apenas, baseado na rota que o usu√°rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os m√©todo GET novamente, por√©m, utilizaremos uma rota din√¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este n√∫mero adicional na rota nos dar√° a capacidade de retornarmos ao usu√°rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisi√ß√£o do usu√°rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisi√ß√µes com metodo GET com um par√¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisi√ß√£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma vari√°vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a vari√°vel n√£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usu√°rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nTemos as duas requisi√ß√µes com o m√©todo GET, para quando o usu√°rio pedir todos os fatos e quando pedir apenas um fato com um espec√≠fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usu√°rio seja capaz de criar um novo fato. \nNo corpo da requisi√ß√£o pegaremos todos os campos necess√°rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade √©:\n- ouvir requisi√ß√µes com o m√©todo POST\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto com as propriedades necess√°rias, id, text, type e upvotes\n- adicionar o novo fato √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com metodo POST\napp.post('/', (request, response) => {\n\t// l√™ o campo text do corpo da requisi√ß√£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // L√™ de forma s√≠ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usu√°rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n### ALTERAR\nJ√° que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usu√°rio altere algum fato em nosso arquivo/banco a partir da rota din√¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez √©:\n- ouvir requisi√ß√µes com o m√©todo PUT e ID\n- pegar campo text do corpo da requisi√ß√£o\n- ler arquivo e guardar em uma vari√°vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado √† vari√°vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com m√©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisi√ß√£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas vari√°veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// vari√°vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usu√°rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da altera√ß√£o, precisando do ID da rota, por√©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, √©:\n- ouvir requisi√ß√µes com o m√©todo DELETE e ID\n- ler arquivo e guardar em uma vari√°vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usu√°rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato n√£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisi√ß√µes com o m√©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma vari√°vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usu√°rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o √≠ndice do fato em quest√£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a vari√°vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do √≠ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n})\n```\n\n# Reorganiza√ß√£o de c√≥digo\n## Criando controller\nSe voc√™ olhar para seu arquivo **server.js**  ele est√° enorme e √© dif√≠cil sua leitura, al√©m de que eventualmente n√≥s podemos querer acrescentar mais funcionalidades, portando, mais c√≥digo ao nosso projeto. \nPara uma melhor manuten√ß√£o √© importante separarmos aquilo que √© de inicializa√ß√£o/configura√ß√£o do servidor do que √© funcionalidade para o usu√°rio.\nEnt√£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara come√ßar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os m√≥dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a vari√°vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 m√©todos, index, show, create, update e delete, todos com os mesmo par√¢metros, request e  response, e ao final exportaremos a classe como um m√≥dulo.\n\n```js\n// importa m√≥dulo path  \nconst path = require('path')  \n// importa m√≥dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO pr√≥ximo passo para organizarmos nosso c√≥digo √© mover algumas partes de c√≥digo que est√£o no **server.js** para este arquivo. Portanto, todo o c√≥digo dentro de `app.get('/', (request, response){...})` ficar√° dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// L√™ de forma s√≠ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usu√°rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'N√£o foi poss√≠vel executar esta opera√ß√£o!' })  \n\t}\n}\n```\nO mesmo ser√° feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora n√£o est√° se comunicando com o servidor/Express e para deixar nosso c√≥digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diret√≥rio do arquivo **server.js**. Este arquivo ir√° conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um m√≥dulo, usando **./controllers/FactsController** para sinalizar que √© um m√≥dulo criado no projeto. Importaremos tamb√©m o m√≥dulo Express, por√©m, dessa vez iniciaremos um roteador, e n√£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um m√≥dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos c√≥digos que n√£o est√£o mais sendo usados pelo servidor. Ent√£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma fun√ß√£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisi√ß√µes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja f√°cil a manuten√ß√£o, ainda n√£o √© o ideal, mas √© o suficiente!\n\nSe voc√™ chegou at√© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu pr√≥prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma s√©rie de posts envolvendo o desenvolvimento de aplica√ß√µes Back End e Front End.\n\nDeixe seu coment√°rio dizendo o que est√° bom e o que √© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":[{"title":"PostgreSQL + Docker = üíô","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, con...","content":"Assim como v√°rias outra t√©cnologias, o PostgreSQL tamb√©m disponibiliza sua vers√£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta pr√°tica de conteineriza√ß√£o possibilita uma configura√ß√£o r√°pida de ambientes de desenvolvimento, testes e produ√ß√£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta gr√°fica de administra√ß√£o que, por sua vez, tamb√©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar v√°rios cont√™ineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSer√° demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar cont√™ineres a partir de imagens](#clock4-criar-cont√™ineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, √© esperado que voc√™ tenha conhecimento b√°sico das tecnologias citadas. Certifique-se de que h√° instalado em sua m√°quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial s√£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) s√£o pontes de comunica√ß√£o que possiblitam √† cont√™ineres uma conex√£o entre eles. Geralmente, criasse uma network quando dois ou mias cont√™ineres t√™m uma rela√ß√£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que ser√° utilizada nesse tutorial, √© poss√≠vel ver quais outras networks est√£o sendo utilizadas em sua m√°quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume √© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o cont√™iner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso ser√° criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua m√°quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar cont√™ineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar √© preciso se atentar √† alguns detalhes:\n  \n- Imagens docker s√£o constru√≠das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tamb√©m t√™m uma vers√£o, geralmente estes s√£o vers√µes do pr√≥prio produto/servi√ßo escolhido, e caso n√£o seja especificado uma vers√£o sempre ser√° instalado a √∫ltima vers√£o est√°vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial ser√° usado a imagem do PostgreSQL vers√£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 voc√™ ir√° usar a √∫ltima vers√£o est√°vel (mais abaixo). Siga o comando a baixo para criar um cont√™iner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta √∫nica linha foi criado e executado um cont√™iner, em que:\n  \n- **-\\-name**, especificao nome do cont√™iner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a vari√°vel de ambiente do cont√™iner\n  - **POSTGRES_PASSWORD=postgresql**, √© a vari√°vel de ambiente que especificaa senha necess√°ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta ser√° exposta (**5440:5432**), ou seja, ser√° acess√≠vel de fora do docker (utilizar em uma aplica√ß√£o n√£o conteinerizada).\n- **-d**, especificaque ap√≥s criado o cont√™iner seu terminal se separe do cont√™iner e voc√™ consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o cont√™iner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o cont√™iner, neste caso a image **postgres**, vers√£o **12.4** utilizando linux **alpine**.\n  \n√â poss√≠vel ver outras vers√µes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um cont√™iner utilizando a imagem do pgAdmin4 em sua √∫ltima vers√£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando √© muito parecido com o utilizado para criar o cont√™iner do Postgres. Est√£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de vari√°veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTamb√©m, por √∫ltimo se encontra o nome da imagem utilizada para criar o cont√™iner (**dpage/pgadmin4**), como pode ver, desta vez n√£o foi passado nenhuma vers√£o especifica, portanto, por padr√£o √© instalado a √∫ltima vers√£o est√°vel da imagem, outro jeito de especificar a √∫ltima vers√£o da imagem √© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJ√° que foi criado os dois cont√™ineres √© hora de testar se tudo est√° funcionando como esperado. Primeiro rode o comando abaixo para listar todos os cont√™ineres em execu√ß√£o em sua m√°quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois cont√™ineres ainda estejam em execu√ß√£o voc√™ deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.s‚Ä¶\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta √© a mesma exposta na cria√ß√£o do cont√™iner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"P√°gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como vari√°veis de ambiente na cria√ß√£o do cont√™iner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVoc√™ ser√° redirecionado para outra p√°gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"P√°gina inicial pgadmin\" width=\"384px\"/>\n  \nPor√©m, ainda n√£o h√° nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o bot√£o direito em cima do \"Servers\" no canto superior esquerdo, v√° em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal ser√° aberto onde voc√™ ir√° inserir informa√ß√µes sobre o servidor. No campo \"name\" adicione um nome de sua prefer√™ncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do cont√™iner \"**postgres**\" (nome do cont√™iner Postgres).\n- No campo \"Port\" utilize a porta interna do cont√™iner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como est√°.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como vari√°vel de ambiente na cria√ß√£o do cont√™iner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no bot√£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVer√° que o servidor foi criado e agora voc√™ tem acesso ao banco de dados do mesmo modo se n√£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados √© o nome do cont√™iner (**postgres**) e a porta √© a interna (**5432**). J√° para acesso externo, como em uma aplica√ß√£o feita em NodeJS, o host √© \"**localhost**\" ou \"**127.0.0.1**\" e a porta √© a porta externa especificada na cria√ß√£o do cont√™iner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de cria√ß√£o dos cont√™ineres pode ser feito utilizando um arquivo que por conven√ß√£o/padr√£o √© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, al√©m disso adiciona o conceito de **stack**.\n  \nStack nada mais √© que um conjunto de cont√™ineres que tem uma rela√ß√£o entre si, voc√™ pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack ser√° o nome da pasta em que o arquivo est√°. Ao criar uma network dentro de uma stack o nome desta network ter√° como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para come√ßar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack ser√° **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua prefer√™ncia e comece adicionando o b√°sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que h√°:\n  \n- **version** - vers√£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, ser√° nomeada **postgres-network**, pois ser√° adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do cont√™iner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma √∫nica linha, ser√° criado um cont√™iner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora √© a vez de reescrever script do cont√™iner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTamb√©m, como no cont√™iner **postgres**, est√° tudo bem parecido com escrito anteriormente utilizando uma √∫nica linha. O nome, email, senha, porta e network continuam o mesmo, por√©m tamb√©m foi adicionado um atributo novo, **depends_on**, este permite que o cont√™iner **pgadmin** n√£o seja criado/iniciado antes do cont√™iner **postgres** ser criado/iniciado.\n  \nPor√©m, antes de executar o arquivo ser√° necess√°rio deletar os cont√™ineres j√° existente afinal n√£o ser√£o mais utilizados como anteriormente, agora eles pertecer√£o √† uma stack. Primeiro pare os dois cont√™ineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os cont√™ineres configurados no arquivo sejam criandos, caso ainda n√£o exista, e os execute. Ainda, quando algo for alterado no arquivo os cont√™ineres afetados ser√£o reconstruidos.\n  \nEm algum momento, caso voc√™ queira parar todos os cont√™ineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, j√° ter um arquivo/script de instala√ß√£o econimiza bastante tempo, afinal n√£o √© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na m√£o.\n  \n> O pregui√ßoso sempre arruma um jeito de n√£o ter trabalho.\n  \nPor fim, agrade√ßo voc√™ por ter chegado at√© aqui, deixe seu coment√°rio e sugest√£o para os pr√≥ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":["[Circular ~.2.suggestions.1]","[Circular ~.2]"]},"[Circular ~.2]"]}]}]