[{"title":"PostgreSQL + Docker = ğŸ’™","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, con...","content":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta prÃ¡tica de conteinerizaÃ§Ã£o possibilita uma configuraÃ§Ã£o rÃ¡pida de ambientes de desenvolvimento, testes e produÃ§Ã£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta grÃ¡fica de administraÃ§Ã£o que, por sua vez, tambÃ©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar vÃ¡rios contÃªineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSerÃ¡ demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar contÃªineres a partir de imagens](#clock4-criar-contÃªineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, Ã© esperado que vocÃª tenha conhecimento bÃ¡sico das tecnologias citadas. Certifique-se de que hÃ¡ instalado em sua mÃ¡quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial sÃ£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) sÃ£o pontes de comunicaÃ§Ã£o que possiblitam Ã  contÃªineres uma conexÃ£o entre eles. Geralmente, criasse uma network quando dois ou mias contÃªineres tÃªm uma relaÃ§Ã£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que serÃ¡ utilizada nesse tutorial, Ã© possÃ­vel ver quais outras networks estÃ£o sendo utilizadas em sua mÃ¡quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume Ã© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o contÃªiner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso serÃ¡ criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua mÃ¡quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar contÃªineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar Ã© preciso se atentar Ã  alguns detalhes:\n  \n- Imagens docker sÃ£o construÃ­das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tambÃ©m tÃªm uma versÃ£o, geralmente estes sÃ£o versÃµes do prÃ³prio produto/serviÃ§o escolhido, e caso nÃ£o seja especificado uma versÃ£o sempre serÃ¡ instalado a Ãºltima versÃ£o estÃ¡vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial serÃ¡ usado a imagem do PostgreSQL versÃ£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 vocÃª irÃ¡ usar a Ãºltima versÃ£o estÃ¡vel (mais abaixo). Siga o comando a baixo para criar um contÃªiner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta Ãºnica linha foi criado e executado um contÃªiner, em que:\n  \n- **-\\-name**, especificao nome do contÃªiner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a variÃ¡vel de ambiente do contÃªiner\n  - **POSTGRES_PASSWORD=postgresql**, Ã© a variÃ¡vel de ambiente que especificaa senha necessÃ¡ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta serÃ¡ exposta (**5440:5432**), ou seja, serÃ¡ acessÃ­vel de fora do docker (utilizar em uma aplicaÃ§Ã£o nÃ£o conteinerizada).\n- **-d**, especificaque apÃ³s criado o contÃªiner seu terminal se separe do contÃªiner e vocÃª consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o contÃªiner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o contÃªiner, neste caso a image **postgres**, versÃ£o **12.4** utilizando linux **alpine**.\n  \nÃ‰ possÃ­vel ver outras versÃµes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um contÃªiner utilizando a imagem do pgAdmin4 em sua Ãºltima versÃ£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando Ã© muito parecido com o utilizado para criar o contÃªiner do Postgres. EstÃ£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de variÃ¡veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTambÃ©m, por Ãºltimo se encontra o nome da imagem utilizada para criar o contÃªiner (**dpage/pgadmin4**), como pode ver, desta vez nÃ£o foi passado nenhuma versÃ£o especifica, portanto, por padrÃ£o Ã© instalado a Ãºltima versÃ£o estÃ¡vel da imagem, outro jeito de especificar a Ãºltima versÃ£o da imagem Ã© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJÃ¡ que foi criado os dois contÃªineres Ã© hora de testar se tudo estÃ¡ funcionando como esperado. Primeiro rode o comando abaixo para listar todos os contÃªineres em execuÃ§Ã£o em sua mÃ¡quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois contÃªineres ainda estejam em execuÃ§Ã£o vocÃª deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.sâ€¦\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta Ã© a mesma exposta na criaÃ§Ã£o do contÃªiner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"PÃ¡gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como variÃ¡veis de ambiente na criaÃ§Ã£o do contÃªiner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVocÃª serÃ¡ redirecionado para outra pÃ¡gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"PÃ¡gina inicial pgadmin\" width=\"384px\"/>\n  \nPorÃ©m, ainda nÃ£o hÃ¡ nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o botÃ£o direito em cima do \"Servers\" no canto superior esquerdo, vÃ¡ em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal serÃ¡ aberto onde vocÃª irÃ¡ inserir informaÃ§Ãµes sobre o servidor. No campo \"name\" adicione um nome de sua preferÃªncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do contÃªiner \"**postgres**\" (nome do contÃªiner Postgres).\n- No campo \"Port\" utilize a porta interna do contÃªiner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como estÃ¡.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como variÃ¡vel de ambiente na criaÃ§Ã£o do contÃªiner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no botÃ£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVerÃ¡ que o servidor foi criado e agora vocÃª tem acesso ao banco de dados do mesmo modo se nÃ£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados Ã© o nome do contÃªiner (**postgres**) e a porta Ã© a interna (**5432**). JÃ¡ para acesso externo, como em uma aplicaÃ§Ã£o feita em NodeJS, o host Ã© \"**localhost**\" ou \"**127.0.0.1**\" e a porta Ã© a porta externa especificada na criaÃ§Ã£o do contÃªiner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de criaÃ§Ã£o dos contÃªineres pode ser feito utilizando um arquivo que por convenÃ§Ã£o/padrÃ£o Ã© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, alÃ©m disso adiciona o conceito de **stack**.\n  \nStack nada mais Ã© que um conjunto de contÃªineres que tem uma relaÃ§Ã£o entre si, vocÃª pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack serÃ¡ o nome da pasta em que o arquivo estÃ¡. Ao criar uma network dentro de uma stack o nome desta network terÃ¡ como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para comeÃ§ar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack serÃ¡ **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua preferÃªncia e comece adicionando o bÃ¡sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que hÃ¡:\n  \n- **version** - versÃ£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, serÃ¡ nomeada **postgres-network**, pois serÃ¡ adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do contÃªiner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma Ãºnica linha, serÃ¡ criado um contÃªiner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora Ã© a vez de reescrever script do contÃªiner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTambÃ©m, como no contÃªiner **postgres**, estÃ¡ tudo bem parecido com escrito anteriormente utilizando uma Ãºnica linha. O nome, email, senha, porta e network continuam o mesmo, porÃ©m tambÃ©m foi adicionado um atributo novo, **depends_on**, este permite que o contÃªiner **pgadmin** nÃ£o seja criado/iniciado antes do contÃªiner **postgres** ser criado/iniciado.\n  \nPorÃ©m, antes de executar o arquivo serÃ¡ necessÃ¡rio deletar os contÃªineres jÃ¡ existente afinal nÃ£o serÃ£o mais utilizados como anteriormente, agora eles pertecerÃ£o Ã  uma stack. Primeiro pare os dois contÃªineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os contÃªineres configurados no arquivo sejam criandos, caso ainda nÃ£o exista, e os execute. Ainda, quando algo for alterado no arquivo os contÃªineres afetados serÃ£o reconstruidos.\n  \nEm algum momento, caso vocÃª queira parar todos os contÃªineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, jÃ¡ ter um arquivo/script de instalaÃ§Ã£o econimiza bastante tempo, afinal nÃ£o Ã© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na mÃ£o.\n  \n> O preguiÃ§oso sempre arruma um jeito de nÃ£o ter trabalho.\n  \nPor fim, agradeÃ§o vocÃª por ter chegado atÃ© aqui, deixe seu comentÃ¡rio e sugestÃ£o para os prÃ³ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":[{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso vocÃª nÃ£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conteÃºdos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a mÃ£o na massa](#botando-a-mÃ£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [ReorganizaÃ§Ã£o de cÃ³digo](#reorganizaÃ§Ã£o-de-cÃ³digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada alteraÃ§Ã£o importante no cÃ³digo fazer um commit. Isso permite que caso algo dÃª errado seja possÃ­vel recuperar a Ãºltima versÃ£o correta do cÃ³digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJÃ¡ temos nossa organizaÃ§Ã£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e comeÃ§armos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de cÃ³digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o prÃ³ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a mÃ£o na massa\nCom a pasta **server_node** aberta no VS Code como diretÃ³rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora Ã© preciso apenas comeÃ§ar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma variÃ¡vel, no nosso caso **app**,  como uma funÃ§Ã£o.\n\nAgora, diga ao **app** escutar requisiÃ§Ãµes na porta 3000, como estÃ¡ abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui Ã  app como uma funÃ§Ã£o\nconst app = express()\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente comeÃ§ou, temos um servidor que escuta na porta 3000 da nossa mÃ¡quina, porÃ©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplicaÃ§Ãµes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requiÃ§Ã£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisiÃ§Ãµes HTTP\n - falamos para o app/express utilizar o cors em sua execuÃ§Ã£o\n - falamos para o app/express utilizar o morgan em sua execuÃ§Ã£o\n - finalmente, criamos uma rota com o mÃ©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o bÃ¡sico bÃ¡sico de um servidor em node, porÃ©m atÃ© agora nÃ£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor Ã© um programa que fica sempre em execuÃ§Ã£o, apenas interrompido quando hÃ¡ algum erro ou outro programa/usuÃ¡rio forÃ§a sua interrupÃ§Ã£o, ele ficarÃ¡ esperando requisiÃ§Ãµes. Portanto, faÃ§a uma requisiÃ§Ã£o, pelo prÃ³prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, vocÃª receberÃ¡ um **ok** na pÃ¡gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, porÃ©m tambÃ©m nÃ£o se reinicia quando fizermos alguma alteraÃ§Ã£o no cÃ³digo, para isso preparamos o script **dev**. Portanto, interrompa a execuÃ§Ã£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJÃ¡ que programamos nossa primeira rota, Ã© hora de realmente retornar ao usuÃ¡rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois mÃ³dulos padrÃµes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, provÃª mÃ©todos para facilmente trabalhar com caminhos dentro do node\n- fs, provÃª mÃ©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na variÃ¡vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o mÃ©todo **readFileSync** do mÃ³dulo **fs** (sempre retorna string)\n - Fazemos o parse/transformaÃ§Ã£o da string para o formato json\n - Retornamos o json para o usuÃ¡rio\n\nÃ‰ pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usuÃ¡rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto Ã© possÃ­vel ver como funciona um servidor API Rest, o usuÃ¡rio faz uma requisiÃ§Ã£o e o retorno Ã© apenas em json, nada de HTML.\n\nNosso cÃ³digo estÃ¡ bem enxuto, e queremos isto, algo simples, de fÃ¡cil entendimento, porÃ©m que resolva o proposto. PorÃ©m, nÃ£o estamos tratando nenhuma exceÃ§Ã£o ou erro que possa acontecer durante a execuÃ§Ã£o.\n\nPara resolver esse problema vamos envolver todo o conteÃºdo dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usuÃ¡rio. Mas ainda nÃ£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usuÃ¡rio de cÃ³digo 200, e caso dÃª algum problema durante a execuÃ§Ã£o do nosso cÃ³digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usuÃ¡rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execuÃ§Ã£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento jÃ¡ estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. EntÃ£o, no prÃ³ximo criaremos a leitura de um dado apenas, baseado na rota que o usuÃ¡rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os mÃ©todo GET novamente, porÃ©m, utilizaremos uma rota dinÃ¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este nÃºmero adicional na rota nos darÃ¡ a capacidade de retornarmos ao usuÃ¡rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisiÃ§Ã£o do usuÃ¡rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisiÃ§Ãµes com metodo GET com um parÃ¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisiÃ§Ã£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma variÃ¡vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a variÃ¡vel nÃ£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usuÃ¡rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nTemos as duas requisiÃ§Ãµes com o mÃ©todo GET, para quando o usuÃ¡rio pedir todos os fatos e quando pedir apenas um fato com um especÃ­fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usuÃ¡rio seja capaz de criar um novo fato. \nNo corpo da requisiÃ§Ã£o pegaremos todos os campos necessÃ¡rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo POST\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto com as propriedades necessÃ¡rias, id, text, type e upvotes\n- adicionar o novo fato Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com metodo POST\napp.post('/', (request, response) => {\n\t// lÃª o campo text do corpo da requisiÃ§Ã£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usuÃ¡rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n### ALTERAR\nJÃ¡ que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usuÃ¡rio altere algum fato em nosso arquivo/banco a partir da rota dinÃ¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo PUT e ID\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com mÃ©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisiÃ§Ã£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas variÃ¡veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// variÃ¡vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usuÃ¡rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da alteraÃ§Ã£o, precisando do ID da rota, porÃ©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo DELETE e ID\n- ler arquivo e guardar em uma variÃ¡vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com o mÃ©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma variÃ¡vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o Ã­ndice do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do Ã­ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n\n# ReorganizaÃ§Ã£o de cÃ³digo\n## Criando controller\nSe vocÃª olhar para seu arquivo **server.js**  ele estÃ¡ enorme e Ã© difÃ­cil sua leitura, alÃ©m de que eventualmente nÃ³s podemos querer acrescentar mais funcionalidades, portando, mais cÃ³digo ao nosso projeto. \nPara uma melhor manutenÃ§Ã£o Ã© importante separarmos aquilo que Ã© de inicializaÃ§Ã£o/configuraÃ§Ã£o do servidor do que Ã© funcionalidade para o usuÃ¡rio.\nEntÃ£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara comeÃ§ar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os mÃ³dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a variÃ¡vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 mÃ©todos, index, show, create, update e delete, todos com os mesmo parÃ¢metros, request e  response, e ao final exportaremos a classe como um mÃ³dulo.\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO prÃ³ximo passo para organizarmos nosso cÃ³digo Ã© mover algumas partes de cÃ³digo que estÃ£o no **server.js** para este arquivo. Portanto, todo o cÃ³digo dentro de `app.get('/', (request, response){...})` ficarÃ¡ dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usuÃ¡rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nO mesmo serÃ¡ feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora nÃ£o estÃ¡ se comunicando com o servidor/Express e para deixar nosso cÃ³digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diretÃ³rio do arquivo **server.js**. Este arquivo irÃ¡ conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um mÃ³dulo, usando **./controllers/FactsController** para sinalizar que Ã© um mÃ³dulo criado no projeto. Importaremos tambÃ©m o mÃ³dulo Express, porÃ©m, dessa vez iniciaremos um roteador, e nÃ£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um mÃ³dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos cÃ³digos que nÃ£o estÃ£o mais sendo usados pelo servidor. EntÃ£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja fÃ¡cil a manutenÃ§Ã£o, ainda nÃ£o Ã© o ideal, mas Ã© o suficiente!\n\nSe vocÃª chegou atÃ© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu prÃ³prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma sÃ©rie de posts envolvendo o desenvolvimento de aplicaÃ§Ãµes Back End e Front End.\n\nDeixe seu comentÃ¡rio dizendo o que estÃ¡ bom e o que Ã© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":["[Circular ~.0]",{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, Ã© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo sÃ£o listados alguns dos conhecimentos que serÃ£o descritos e ensinados neste tutorial:\n\n- Boas prÃ¡ticas de programaÃ§Ã£o\n- DefiniÃ§Ã£o de um sistema de pastas simples e eficiente\n- Iniciar um repositÃ³rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de comeÃ§ar Ã© preciso certificar-se de que alguns programas estÃ£o instalados na mÃ¡quina que serÃ¡ utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execuÃ§Ã£o de cÃ³digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de cÃ³digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de cÃ³digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisiÃ§Ãµes HTTP.\n\nÃ‰ necessÃ¡rio criar uma conta criada no [GitHub](https://github.com/). O GitHub Ã© a plataforma de hospedagem de cÃ³digo-fonte e possui controle de versÃ£o. Essa plataforma poderÃ¡ auxiliar no transporte do cÃ³digo para outro lugar, como para a faculdade ou trabalho.\n\nÃ‰ importante saber o que Ã© um servidor REST, o que Ã© HTTP e como utilizar o Insomnia para fazer requisiÃ§Ãµes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que estÃ¡ sendo montado:\n\n- [O que Ã© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (vÃ­deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir sÃ£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conteÃºdos\n- [Criando pastas](#criando-pastas)\n- [Criando um repositÃ³rio utilizando GitHub](#criando-um-repositÃ³rio-utilizando-github)\n- [Criando um repositÃ³rio sem GitHub](#criando-um-repositÃ³rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [DomÃ­nio](#domÃ­nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [CabeÃ§alhos](#cabeÃ§alhos)\n\t\t- [MÃ©todos](#mÃ©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [ParÃ¢metros (Query String)](#parÃ¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com parÃ¢metros](#get-com-parÃ¢metros)\n\t\t- [GET com rota dinÃ¢mica](#get-com-rota-dinÃ¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara comeÃ§ar serÃ¡ criada uma pasta inicial chamada **server_node**. ApÃ³s criÃ¡-la Ã© necessÃ¡rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois Ã© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto sÃ£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. PorÃ©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estarÃ£o os cÃ³digos que controlaram as funcionalidade do usuÃ¡rio, e outra chamada **db**. Na pasta db estarÃ£o todas a informaÃ§Ã£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas Ã© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os prÃ³ximos passo Ã© necessÃ¡rio que o diretÃ³rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diretÃ³rio atual Ã© **src** dentro de **server_node**. Para voltar diretÃ³rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um repositÃ³rio utilizando GitHub\n\nCaso vocÃª tenha uma conta criada no GitHub, [crie um novo repositÃ³rio](https://github.com/new) com nome **server_node**, sem gitignore, licenÃ§a e readme.\nLogo apÃ³s criado o repositÃ³rio irÃ¡ aparecer algumas opÃ§Ãµes para iniciar o mesmo. Copie todo o conteÃºdo da opÃ§Ã£o **criar um novo repositÃ³rio usando linha de comando**, no meu caso o cÃ³digo Ã© o mostrado abaixo. Cole o conteÃºdo no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conteÃºdo \"# server_node\"\ngit init # inicia um repositÃ³rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu repositÃ³rio para o GitHub\n```\n\n# Criando um repositÃ³rio sem GitHub\n\nCaso vocÃª nÃ£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o cÃ³digo abaixo para iniciar seu versionamento de cÃ³digo local.\n\n```bash\ngit init # inicia repositÃ³rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS Ã© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descriÃ§Ã£o do projeto\n- version, versÃ£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licenÃ§a utilizada no projeto\n- private, se este projeto pode ser publicÃ¡vel ou nÃ£o\n- scripts, comandos de execuÃ§Ã£o\n- dependencies, dependÃªncias principais do projeto\n- devdependencies, dependÃªncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na mÃ£o, Ã© muito mais fÃ¡cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, apÃ³s executar, serÃ¡ necessÃ¡rio preencher alguns dados, como Ã© mostrado abaixo.\n\n```bash\nyarn init # inicia repositÃ³rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes sÃ£o mÃ³dulos, cÃ³digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome jÃ¡ sugere, pacotes principais sÃ£o mÃ³dulos que seu cÃ³digo irÃ¡ precisar mesmo quando em produÃ§Ã£o e pacotes de desenvolvimento sÃ£o mÃ³dulos que vocÃª usarÃ¡ apenas quando estiver programando.\nMÃ³dulos que usaremos sÃ£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplicaÃ§Ã£o faÃ§a requisiÃ§Ã£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisiÃ§Ã£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada alteraÃ§Ã£o no cÃ³digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** Ã© criada, nela estÃ¡ todos os pacotes baixados. Ainda, note que cada vez que vocÃª adiciona ou remove um pacote o arquivo **package.json** Ã© alterado. Isso serve para caso vocÃª precise copiar seu cÃ³digo para outra mÃ¡quina, vocÃª nÃ£o precise copiar a pasta **node_modules** junto, e seja necessÃ¡rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** serÃ£o instalados e automaticamente serÃ¡ criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** serÃ¡ o script para executarmos o servidor em desenvolvimento, reiniciando a cada modificaÃ§Ã£o no cÃ³digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** serÃ¡ o script que utilizaremos quando quisermos executar nosso servidor em produÃ§Ã£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e dependÃªncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de comeÃ§armos a codar precisamos lembrar de alguns conceitos de requisiÃ§Ãµes HTTP.\nPara fazermos uma requisiÃ§Ã£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o domÃ­nio, a porta, a rota, os cabeÃ§alhos (headers), o corpo (body) e os parÃ¢metros (query string).\n\n## DomÃ­nio\n\nDomÃ­nio, de forma bem ampla, Ã© o nome do servidor, este Ã© um jeito utilizado para nÃ£o precisarmos escrever o IP de todo site que quisermos acessar. O domÃ­nio, assim como o IP, Ã© Ãºnico e Ã© reconhecido por toda a internet. Como exemplo, a Google tem um domÃ­nio global `google.com`\nque por trÃ¡s estÃ¡ um IP `172.217.28.78`.\n\nA Ãºnica exceÃ§Ã£o de domÃ­nio e IP que se repete em toda mÃ¡quina Ã© o local. Toda mÃ¡quina mÃ¡quina consegue se acessar usando o domÃ­nio local `localhost` e IP `127.0.0.1`, portanto uma mÃ¡quina nÃ£o consegue acessar um aplicaÃ§Ã£o de outra mÃ¡quina utilizando o domÃ­nio `localhost`, pois ela tentarÃ¡ acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, sÃ£o conexÃµes de cada aplicaÃ§Ã£o dentro da nossa mÃ¡quina. Cada aplicaÃ§Ã£o utiliza uma ou mais portas para se comunicar com outra aplicaÃ§Ã£o, internamente ou nÃ£o. Em nossa mÃ¡quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padrÃ£o HTTP utiliza a porta 80, por isso muita das vezes nÃ£o precisamos explicitamente colocar a porta ao acessar um site.\nFaÃ§a o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso vocÃª conseguirÃ¡ acessar o site, porÃ©m no seguindo caso o navegador nÃ£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, porÃ©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, Ã© o caminho em que o usuÃ¡rio faz uma requisiÃ§Ã£o ao servidor.\nSendo assim, um caminho dita qual conteÃºdo vocÃª espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a pÃ¡gina de busca do site `/` , jÃ¡ no segundo caso pedimos ao servidor do google que nos mostre a pÃ¡gina doodles `/doodles/`.\n\nServidores tÃªm a possibilidade tambÃ©m de criar rotas dinÃ¢micas, estas sÃ£o rotas geradas automaticamente para requisiÃ§Ã£o de um dado especÃ­fico mas que o tratamento desse dado Ã© genÃ©rico. Como, buscar dados de um usuÃ¡rio especÃ­fico. O servidor irÃ¡ retornar os dados apenas daquele usuÃ¡rio, porÃ©m o tratamento no servidor Ã© genÃ©rico, de forma que consiga buscar qualquer usuÃ¡rio dentro do banco de dados.\n\n## CabeÃ§alhos\n\nOs cabeÃ§alhos tÃªm informaÃ§Ãµes importantes sobre o usuÃ¡rio e tambÃ©m sobre o servidor (no retorno).\nNos cabeÃ§alhos conseguimos encontrar o mÃ©todo/verbo da requisiÃ§Ã£o (GET, POST, PUT, DELETE, entre outros), o tipo do conteÃºdo da requisiÃ§Ã£o, o tamanho do conteÃºdo enviado na requisiÃ§Ã£o, qual aplicaÃ§Ã£o fez a requisiÃ§Ã£o, o domÃ­nio em que o usuÃ¡rio estÃ¡, entre outros.\n\n### MÃ©todos\n\nComo dito antes, nos cabeÃ§alhos Ã© possÃ­vel encontrar o mÃ©todo/verbo da requisiÃ§Ã£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conteÃºdos do cabeÃ§alho, no servidores com **Express** sempre precisamos falar quais mÃ©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padrÃ£o utilizam apenas os mÃ©todos GET e POST, portanto, para utilizar outro mÃ©todo Ã© necessÃ¡rio utilizar JavaScript em uma requisiÃ§Ã£o.\n\n#### GET\n\nPor padrÃ£o Ã© utilizado quando queremos apenas o retorno de algum dado/pÃ¡gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usuÃ¡rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor, porÃ©m, desta vez estamos modificando um dado jÃ¡ existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo Ã© um espaÃ§o na requisiÃ§Ã£o HTTP onde os dados de um formulÃ¡rio sÃ£o enviados ao servidor. HÃ¡ vÃ¡rios tipos de conteÃºdos que podem ser enviados no corpo, por isso do campo `tipo de contÃ©udo` dentro dos cabeÃ§alhos.\n\n## ParÃ¢metros (Query String)\n\nParÃ¢metros, como o nome jÃ¡ indica, sÃ£o parÃ¢metros que passamos junto a rota, geralmente sÃ£o utilizados como filtros para alguma requisiÃ§Ã£o.\n\nUm exemplo de parÃ¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um parÃ¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais parÃ¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os parÃ¢metros sÃ£o utilizados junto ao mÃ©todo GET, para filtragem de resultados no servidor. PorÃ©m nada impede de ser usados junto a outro mÃ©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- MÃ©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com parÃ¢metros\n\n- MÃ©todo: GET\n- Rota: /nomes\n- ParÃ¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho mÃ¡ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota dinÃ¢mica\n\n- MÃ©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informaÃ§Ãµes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- MÃ©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- MÃ©todo: PUT\n- Rota dinÃ¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- MÃ©todo: DELETE\n- Rota dinÃ¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso repositÃ³rio, iniciamos o projeto com Yarn, instalamos alguns mÃ³dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisiÃ§Ã£o HTTP.\n\nAgora estamos prontos para ir para a prÃ³xima fase, onde realmente colocamos a mÃ£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de vocÃª ter chegado atÃ© aqui! Espero que eu tenha lhe passado algum conhecimento. EntÃ£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":["[Circular ~.0]","[Circular ~.0.suggestions.0]"]}]},{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, Ã© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo sÃ£o listados alguns dos conhecimentos que serÃ£o descritos e ensinados neste tutorial:\n\n- Boas prÃ¡ticas de programaÃ§Ã£o\n- DefiniÃ§Ã£o de um sistema de pastas simples e eficiente\n- Iniciar um repositÃ³rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de comeÃ§ar Ã© preciso certificar-se de que alguns programas estÃ£o instalados na mÃ¡quina que serÃ¡ utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execuÃ§Ã£o de cÃ³digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de cÃ³digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de cÃ³digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisiÃ§Ãµes HTTP.\n\nÃ‰ necessÃ¡rio criar uma conta criada no [GitHub](https://github.com/). O GitHub Ã© a plataforma de hospedagem de cÃ³digo-fonte e possui controle de versÃ£o. Essa plataforma poderÃ¡ auxiliar no transporte do cÃ³digo para outro lugar, como para a faculdade ou trabalho.\n\nÃ‰ importante saber o que Ã© um servidor REST, o que Ã© HTTP e como utilizar o Insomnia para fazer requisiÃ§Ãµes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que estÃ¡ sendo montado:\n\n- [O que Ã© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (vÃ­deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir sÃ£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conteÃºdos\n- [Criando pastas](#criando-pastas)\n- [Criando um repositÃ³rio utilizando GitHub](#criando-um-repositÃ³rio-utilizando-github)\n- [Criando um repositÃ³rio sem GitHub](#criando-um-repositÃ³rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [DomÃ­nio](#domÃ­nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [CabeÃ§alhos](#cabeÃ§alhos)\n\t\t- [MÃ©todos](#mÃ©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [ParÃ¢metros (Query String)](#parÃ¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com parÃ¢metros](#get-com-parÃ¢metros)\n\t\t- [GET com rota dinÃ¢mica](#get-com-rota-dinÃ¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara comeÃ§ar serÃ¡ criada uma pasta inicial chamada **server_node**. ApÃ³s criÃ¡-la Ã© necessÃ¡rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois Ã© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto sÃ£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. PorÃ©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estarÃ£o os cÃ³digos que controlaram as funcionalidade do usuÃ¡rio, e outra chamada **db**. Na pasta db estarÃ£o todas a informaÃ§Ã£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas Ã© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os prÃ³ximos passo Ã© necessÃ¡rio que o diretÃ³rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diretÃ³rio atual Ã© **src** dentro de **server_node**. Para voltar diretÃ³rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um repositÃ³rio utilizando GitHub\n\nCaso vocÃª tenha uma conta criada no GitHub, [crie um novo repositÃ³rio](https://github.com/new) com nome **server_node**, sem gitignore, licenÃ§a e readme.\nLogo apÃ³s criado o repositÃ³rio irÃ¡ aparecer algumas opÃ§Ãµes para iniciar o mesmo. Copie todo o conteÃºdo da opÃ§Ã£o **criar um novo repositÃ³rio usando linha de comando**, no meu caso o cÃ³digo Ã© o mostrado abaixo. Cole o conteÃºdo no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conteÃºdo \"# server_node\"\ngit init # inicia um repositÃ³rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu repositÃ³rio para o GitHub\n```\n\n# Criando um repositÃ³rio sem GitHub\n\nCaso vocÃª nÃ£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o cÃ³digo abaixo para iniciar seu versionamento de cÃ³digo local.\n\n```bash\ngit init # inicia repositÃ³rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS Ã© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descriÃ§Ã£o do projeto\n- version, versÃ£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licenÃ§a utilizada no projeto\n- private, se este projeto pode ser publicÃ¡vel ou nÃ£o\n- scripts, comandos de execuÃ§Ã£o\n- dependencies, dependÃªncias principais do projeto\n- devdependencies, dependÃªncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na mÃ£o, Ã© muito mais fÃ¡cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, apÃ³s executar, serÃ¡ necessÃ¡rio preencher alguns dados, como Ã© mostrado abaixo.\n\n```bash\nyarn init # inicia repositÃ³rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes sÃ£o mÃ³dulos, cÃ³digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome jÃ¡ sugere, pacotes principais sÃ£o mÃ³dulos que seu cÃ³digo irÃ¡ precisar mesmo quando em produÃ§Ã£o e pacotes de desenvolvimento sÃ£o mÃ³dulos que vocÃª usarÃ¡ apenas quando estiver programando.\nMÃ³dulos que usaremos sÃ£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplicaÃ§Ã£o faÃ§a requisiÃ§Ã£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisiÃ§Ã£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada alteraÃ§Ã£o no cÃ³digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** Ã© criada, nela estÃ¡ todos os pacotes baixados. Ainda, note que cada vez que vocÃª adiciona ou remove um pacote o arquivo **package.json** Ã© alterado. Isso serve para caso vocÃª precise copiar seu cÃ³digo para outra mÃ¡quina, vocÃª nÃ£o precise copiar a pasta **node_modules** junto, e seja necessÃ¡rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** serÃ£o instalados e automaticamente serÃ¡ criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** serÃ¡ o script para executarmos o servidor em desenvolvimento, reiniciando a cada modificaÃ§Ã£o no cÃ³digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** serÃ¡ o script que utilizaremos quando quisermos executar nosso servidor em produÃ§Ã£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e dependÃªncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de comeÃ§armos a codar precisamos lembrar de alguns conceitos de requisiÃ§Ãµes HTTP.\nPara fazermos uma requisiÃ§Ã£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o domÃ­nio, a porta, a rota, os cabeÃ§alhos (headers), o corpo (body) e os parÃ¢metros (query string).\n\n## DomÃ­nio\n\nDomÃ­nio, de forma bem ampla, Ã© o nome do servidor, este Ã© um jeito utilizado para nÃ£o precisarmos escrever o IP de todo site que quisermos acessar. O domÃ­nio, assim como o IP, Ã© Ãºnico e Ã© reconhecido por toda a internet. Como exemplo, a Google tem um domÃ­nio global `google.com`\nque por trÃ¡s estÃ¡ um IP `172.217.28.78`.\n\nA Ãºnica exceÃ§Ã£o de domÃ­nio e IP que se repete em toda mÃ¡quina Ã© o local. Toda mÃ¡quina mÃ¡quina consegue se acessar usando o domÃ­nio local `localhost` e IP `127.0.0.1`, portanto uma mÃ¡quina nÃ£o consegue acessar um aplicaÃ§Ã£o de outra mÃ¡quina utilizando o domÃ­nio `localhost`, pois ela tentarÃ¡ acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, sÃ£o conexÃµes de cada aplicaÃ§Ã£o dentro da nossa mÃ¡quina. Cada aplicaÃ§Ã£o utiliza uma ou mais portas para se comunicar com outra aplicaÃ§Ã£o, internamente ou nÃ£o. Em nossa mÃ¡quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padrÃ£o HTTP utiliza a porta 80, por isso muita das vezes nÃ£o precisamos explicitamente colocar a porta ao acessar um site.\nFaÃ§a o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso vocÃª conseguirÃ¡ acessar o site, porÃ©m no seguindo caso o navegador nÃ£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, porÃ©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, Ã© o caminho em que o usuÃ¡rio faz uma requisiÃ§Ã£o ao servidor.\nSendo assim, um caminho dita qual conteÃºdo vocÃª espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a pÃ¡gina de busca do site `/` , jÃ¡ no segundo caso pedimos ao servidor do google que nos mostre a pÃ¡gina doodles `/doodles/`.\n\nServidores tÃªm a possibilidade tambÃ©m de criar rotas dinÃ¢micas, estas sÃ£o rotas geradas automaticamente para requisiÃ§Ã£o de um dado especÃ­fico mas que o tratamento desse dado Ã© genÃ©rico. Como, buscar dados de um usuÃ¡rio especÃ­fico. O servidor irÃ¡ retornar os dados apenas daquele usuÃ¡rio, porÃ©m o tratamento no servidor Ã© genÃ©rico, de forma que consiga buscar qualquer usuÃ¡rio dentro do banco de dados.\n\n## CabeÃ§alhos\n\nOs cabeÃ§alhos tÃªm informaÃ§Ãµes importantes sobre o usuÃ¡rio e tambÃ©m sobre o servidor (no retorno).\nNos cabeÃ§alhos conseguimos encontrar o mÃ©todo/verbo da requisiÃ§Ã£o (GET, POST, PUT, DELETE, entre outros), o tipo do conteÃºdo da requisiÃ§Ã£o, o tamanho do conteÃºdo enviado na requisiÃ§Ã£o, qual aplicaÃ§Ã£o fez a requisiÃ§Ã£o, o domÃ­nio em que o usuÃ¡rio estÃ¡, entre outros.\n\n### MÃ©todos\n\nComo dito antes, nos cabeÃ§alhos Ã© possÃ­vel encontrar o mÃ©todo/verbo da requisiÃ§Ã£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conteÃºdos do cabeÃ§alho, no servidores com **Express** sempre precisamos falar quais mÃ©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padrÃ£o utilizam apenas os mÃ©todos GET e POST, portanto, para utilizar outro mÃ©todo Ã© necessÃ¡rio utilizar JavaScript em uma requisiÃ§Ã£o.\n\n#### GET\n\nPor padrÃ£o Ã© utilizado quando queremos apenas o retorno de algum dado/pÃ¡gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usuÃ¡rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor, porÃ©m, desta vez estamos modificando um dado jÃ¡ existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo Ã© um espaÃ§o na requisiÃ§Ã£o HTTP onde os dados de um formulÃ¡rio sÃ£o enviados ao servidor. HÃ¡ vÃ¡rios tipos de conteÃºdos que podem ser enviados no corpo, por isso do campo `tipo de contÃ©udo` dentro dos cabeÃ§alhos.\n\n## ParÃ¢metros (Query String)\n\nParÃ¢metros, como o nome jÃ¡ indica, sÃ£o parÃ¢metros que passamos junto a rota, geralmente sÃ£o utilizados como filtros para alguma requisiÃ§Ã£o.\n\nUm exemplo de parÃ¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um parÃ¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais parÃ¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os parÃ¢metros sÃ£o utilizados junto ao mÃ©todo GET, para filtragem de resultados no servidor. PorÃ©m nada impede de ser usados junto a outro mÃ©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- MÃ©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com parÃ¢metros\n\n- MÃ©todo: GET\n- Rota: /nomes\n- ParÃ¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho mÃ¡ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota dinÃ¢mica\n\n- MÃ©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informaÃ§Ãµes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- MÃ©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- MÃ©todo: PUT\n- Rota dinÃ¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- MÃ©todo: DELETE\n- Rota dinÃ¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso repositÃ³rio, iniciamos o projeto com Yarn, instalamos alguns mÃ³dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisiÃ§Ã£o HTTP.\n\nAgora estamos prontos para ir para a prÃ³xima fase, onde realmente colocamos a mÃ£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de vocÃª ter chegado atÃ© aqui! Espero que eu tenha lhe passado algum conhecimento. EntÃ£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":["[Circular ~.0]",{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso vocÃª nÃ£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conteÃºdos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a mÃ£o na massa](#botando-a-mÃ£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [ReorganizaÃ§Ã£o de cÃ³digo](#reorganizaÃ§Ã£o-de-cÃ³digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada alteraÃ§Ã£o importante no cÃ³digo fazer um commit. Isso permite que caso algo dÃª errado seja possÃ­vel recuperar a Ãºltima versÃ£o correta do cÃ³digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJÃ¡ temos nossa organizaÃ§Ã£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e comeÃ§armos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de cÃ³digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o prÃ³ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a mÃ£o na massa\nCom a pasta **server_node** aberta no VS Code como diretÃ³rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora Ã© preciso apenas comeÃ§ar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma variÃ¡vel, no nosso caso **app**,  como uma funÃ§Ã£o.\n\nAgora, diga ao **app** escutar requisiÃ§Ãµes na porta 3000, como estÃ¡ abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui Ã  app como uma funÃ§Ã£o\nconst app = express()\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente comeÃ§ou, temos um servidor que escuta na porta 3000 da nossa mÃ¡quina, porÃ©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplicaÃ§Ãµes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requiÃ§Ã£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisiÃ§Ãµes HTTP\n - falamos para o app/express utilizar o cors em sua execuÃ§Ã£o\n - falamos para o app/express utilizar o morgan em sua execuÃ§Ã£o\n - finalmente, criamos uma rota com o mÃ©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o bÃ¡sico bÃ¡sico de um servidor em node, porÃ©m atÃ© agora nÃ£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor Ã© um programa que fica sempre em execuÃ§Ã£o, apenas interrompido quando hÃ¡ algum erro ou outro programa/usuÃ¡rio forÃ§a sua interrupÃ§Ã£o, ele ficarÃ¡ esperando requisiÃ§Ãµes. Portanto, faÃ§a uma requisiÃ§Ã£o, pelo prÃ³prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, vocÃª receberÃ¡ um **ok** na pÃ¡gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, porÃ©m tambÃ©m nÃ£o se reinicia quando fizermos alguma alteraÃ§Ã£o no cÃ³digo, para isso preparamos o script **dev**. Portanto, interrompa a execuÃ§Ã£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJÃ¡ que programamos nossa primeira rota, Ã© hora de realmente retornar ao usuÃ¡rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois mÃ³dulos padrÃµes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, provÃª mÃ©todos para facilmente trabalhar com caminhos dentro do node\n- fs, provÃª mÃ©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na variÃ¡vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o mÃ©todo **readFileSync** do mÃ³dulo **fs** (sempre retorna string)\n - Fazemos o parse/transformaÃ§Ã£o da string para o formato json\n - Retornamos o json para o usuÃ¡rio\n\nÃ‰ pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usuÃ¡rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto Ã© possÃ­vel ver como funciona um servidor API Rest, o usuÃ¡rio faz uma requisiÃ§Ã£o e o retorno Ã© apenas em json, nada de HTML.\n\nNosso cÃ³digo estÃ¡ bem enxuto, e queremos isto, algo simples, de fÃ¡cil entendimento, porÃ©m que resolva o proposto. PorÃ©m, nÃ£o estamos tratando nenhuma exceÃ§Ã£o ou erro que possa acontecer durante a execuÃ§Ã£o.\n\nPara resolver esse problema vamos envolver todo o conteÃºdo dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usuÃ¡rio. Mas ainda nÃ£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usuÃ¡rio de cÃ³digo 200, e caso dÃª algum problema durante a execuÃ§Ã£o do nosso cÃ³digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usuÃ¡rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execuÃ§Ã£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento jÃ¡ estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. EntÃ£o, no prÃ³ximo criaremos a leitura de um dado apenas, baseado na rota que o usuÃ¡rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os mÃ©todo GET novamente, porÃ©m, utilizaremos uma rota dinÃ¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este nÃºmero adicional na rota nos darÃ¡ a capacidade de retornarmos ao usuÃ¡rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisiÃ§Ã£o do usuÃ¡rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisiÃ§Ãµes com metodo GET com um parÃ¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisiÃ§Ã£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma variÃ¡vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a variÃ¡vel nÃ£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usuÃ¡rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nTemos as duas requisiÃ§Ãµes com o mÃ©todo GET, para quando o usuÃ¡rio pedir todos os fatos e quando pedir apenas um fato com um especÃ­fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usuÃ¡rio seja capaz de criar um novo fato. \nNo corpo da requisiÃ§Ã£o pegaremos todos os campos necessÃ¡rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo POST\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto com as propriedades necessÃ¡rias, id, text, type e upvotes\n- adicionar o novo fato Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com metodo POST\napp.post('/', (request, response) => {\n\t// lÃª o campo text do corpo da requisiÃ§Ã£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usuÃ¡rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n### ALTERAR\nJÃ¡ que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usuÃ¡rio altere algum fato em nosso arquivo/banco a partir da rota dinÃ¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo PUT e ID\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com mÃ©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisiÃ§Ã£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas variÃ¡veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// variÃ¡vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usuÃ¡rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da alteraÃ§Ã£o, precisando do ID da rota, porÃ©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo DELETE e ID\n- ler arquivo e guardar em uma variÃ¡vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com o mÃ©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma variÃ¡vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o Ã­ndice do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do Ã­ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n\n# ReorganizaÃ§Ã£o de cÃ³digo\n## Criando controller\nSe vocÃª olhar para seu arquivo **server.js**  ele estÃ¡ enorme e Ã© difÃ­cil sua leitura, alÃ©m de que eventualmente nÃ³s podemos querer acrescentar mais funcionalidades, portando, mais cÃ³digo ao nosso projeto. \nPara uma melhor manutenÃ§Ã£o Ã© importante separarmos aquilo que Ã© de inicializaÃ§Ã£o/configuraÃ§Ã£o do servidor do que Ã© funcionalidade para o usuÃ¡rio.\nEntÃ£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara comeÃ§ar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os mÃ³dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a variÃ¡vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 mÃ©todos, index, show, create, update e delete, todos com os mesmo parÃ¢metros, request e  response, e ao final exportaremos a classe como um mÃ³dulo.\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO prÃ³ximo passo para organizarmos nosso cÃ³digo Ã© mover algumas partes de cÃ³digo que estÃ£o no **server.js** para este arquivo. Portanto, todo o cÃ³digo dentro de `app.get('/', (request, response){...})` ficarÃ¡ dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usuÃ¡rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nO mesmo serÃ¡ feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora nÃ£o estÃ¡ se comunicando com o servidor/Express e para deixar nosso cÃ³digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diretÃ³rio do arquivo **server.js**. Este arquivo irÃ¡ conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um mÃ³dulo, usando **./controllers/FactsController** para sinalizar que Ã© um mÃ³dulo criado no projeto. Importaremos tambÃ©m o mÃ³dulo Express, porÃ©m, dessa vez iniciaremos um roteador, e nÃ£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um mÃ³dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos cÃ³digos que nÃ£o estÃ£o mais sendo usados pelo servidor. EntÃ£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja fÃ¡cil a manutenÃ§Ã£o, ainda nÃ£o Ã© o ideal, mas Ã© o suficiente!\n\nSe vocÃª chegou atÃ© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu prÃ³prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma sÃ©rie de posts envolvendo o desenvolvimento de aplicaÃ§Ãµes Back End e Front End.\n\nDeixe seu comentÃ¡rio dizendo o que estÃ¡ bom e o que Ã© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":["[Circular ~.0]","[Circular ~.0.suggestions.1]"]}]}]},{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso vocÃª nÃ£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conteÃºdos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a mÃ£o na massa](#botando-a-mÃ£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [ReorganizaÃ§Ã£o de cÃ³digo](#reorganizaÃ§Ã£o-de-cÃ³digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada alteraÃ§Ã£o importante no cÃ³digo fazer um commit. Isso permite que caso algo dÃª errado seja possÃ­vel recuperar a Ãºltima versÃ£o correta do cÃ³digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJÃ¡ temos nossa organizaÃ§Ã£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e comeÃ§armos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de cÃ³digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o prÃ³ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a mÃ£o na massa\nCom a pasta **server_node** aberta no VS Code como diretÃ³rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora Ã© preciso apenas comeÃ§ar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma variÃ¡vel, no nosso caso **app**,  como uma funÃ§Ã£o.\n\nAgora, diga ao **app** escutar requisiÃ§Ãµes na porta 3000, como estÃ¡ abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui Ã  app como uma funÃ§Ã£o\nconst app = express()\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente comeÃ§ou, temos um servidor que escuta na porta 3000 da nossa mÃ¡quina, porÃ©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplicaÃ§Ãµes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requiÃ§Ã£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisiÃ§Ãµes HTTP\n - falamos para o app/express utilizar o cors em sua execuÃ§Ã£o\n - falamos para o app/express utilizar o morgan em sua execuÃ§Ã£o\n - finalmente, criamos uma rota com o mÃ©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o bÃ¡sico bÃ¡sico de um servidor em node, porÃ©m atÃ© agora nÃ£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor Ã© um programa que fica sempre em execuÃ§Ã£o, apenas interrompido quando hÃ¡ algum erro ou outro programa/usuÃ¡rio forÃ§a sua interrupÃ§Ã£o, ele ficarÃ¡ esperando requisiÃ§Ãµes. Portanto, faÃ§a uma requisiÃ§Ã£o, pelo prÃ³prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, vocÃª receberÃ¡ um **ok** na pÃ¡gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, porÃ©m tambÃ©m nÃ£o se reinicia quando fizermos alguma alteraÃ§Ã£o no cÃ³digo, para isso preparamos o script **dev**. Portanto, interrompa a execuÃ§Ã£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJÃ¡ que programamos nossa primeira rota, Ã© hora de realmente retornar ao usuÃ¡rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois mÃ³dulos padrÃµes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, provÃª mÃ©todos para facilmente trabalhar com caminhos dentro do node\n- fs, provÃª mÃ©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na variÃ¡vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o mÃ©todo **readFileSync** do mÃ³dulo **fs** (sempre retorna string)\n - Fazemos o parse/transformaÃ§Ã£o da string para o formato json\n - Retornamos o json para o usuÃ¡rio\n\nÃ‰ pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usuÃ¡rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto Ã© possÃ­vel ver como funciona um servidor API Rest, o usuÃ¡rio faz uma requisiÃ§Ã£o e o retorno Ã© apenas em json, nada de HTML.\n\nNosso cÃ³digo estÃ¡ bem enxuto, e queremos isto, algo simples, de fÃ¡cil entendimento, porÃ©m que resolva o proposto. PorÃ©m, nÃ£o estamos tratando nenhuma exceÃ§Ã£o ou erro que possa acontecer durante a execuÃ§Ã£o.\n\nPara resolver esse problema vamos envolver todo o conteÃºdo dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usuÃ¡rio. Mas ainda nÃ£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usuÃ¡rio de cÃ³digo 200, e caso dÃª algum problema durante a execuÃ§Ã£o do nosso cÃ³digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usuÃ¡rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execuÃ§Ã£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento jÃ¡ estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. EntÃ£o, no prÃ³ximo criaremos a leitura de um dado apenas, baseado na rota que o usuÃ¡rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os mÃ©todo GET novamente, porÃ©m, utilizaremos uma rota dinÃ¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este nÃºmero adicional na rota nos darÃ¡ a capacidade de retornarmos ao usuÃ¡rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisiÃ§Ã£o do usuÃ¡rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisiÃ§Ãµes com metodo GET com um parÃ¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisiÃ§Ã£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma variÃ¡vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a variÃ¡vel nÃ£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usuÃ¡rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nTemos as duas requisiÃ§Ãµes com o mÃ©todo GET, para quando o usuÃ¡rio pedir todos os fatos e quando pedir apenas um fato com um especÃ­fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usuÃ¡rio seja capaz de criar um novo fato. \nNo corpo da requisiÃ§Ã£o pegaremos todos os campos necessÃ¡rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo POST\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto com as propriedades necessÃ¡rias, id, text, type e upvotes\n- adicionar o novo fato Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com metodo POST\napp.post('/', (request, response) => {\n\t// lÃª o campo text do corpo da requisiÃ§Ã£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usuÃ¡rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n### ALTERAR\nJÃ¡ que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usuÃ¡rio altere algum fato em nosso arquivo/banco a partir da rota dinÃ¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo PUT e ID\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com mÃ©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisiÃ§Ã£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas variÃ¡veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// variÃ¡vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usuÃ¡rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da alteraÃ§Ã£o, precisando do ID da rota, porÃ©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo DELETE e ID\n- ler arquivo e guardar em uma variÃ¡vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com o mÃ©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma variÃ¡vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o Ã­ndice do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do Ã­ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n\n# ReorganizaÃ§Ã£o de cÃ³digo\n## Criando controller\nSe vocÃª olhar para seu arquivo **server.js**  ele estÃ¡ enorme e Ã© difÃ­cil sua leitura, alÃ©m de que eventualmente nÃ³s podemos querer acrescentar mais funcionalidades, portando, mais cÃ³digo ao nosso projeto. \nPara uma melhor manutenÃ§Ã£o Ã© importante separarmos aquilo que Ã© de inicializaÃ§Ã£o/configuraÃ§Ã£o do servidor do que Ã© funcionalidade para o usuÃ¡rio.\nEntÃ£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara comeÃ§ar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os mÃ³dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a variÃ¡vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 mÃ©todos, index, show, create, update e delete, todos com os mesmo parÃ¢metros, request e  response, e ao final exportaremos a classe como um mÃ³dulo.\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO prÃ³ximo passo para organizarmos nosso cÃ³digo Ã© mover algumas partes de cÃ³digo que estÃ£o no **server.js** para este arquivo. Portanto, todo o cÃ³digo dentro de `app.get('/', (request, response){...})` ficarÃ¡ dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usuÃ¡rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nO mesmo serÃ¡ feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora nÃ£o estÃ¡ se comunicando com o servidor/Express e para deixar nosso cÃ³digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diretÃ³rio do arquivo **server.js**. Este arquivo irÃ¡ conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um mÃ³dulo, usando **./controllers/FactsController** para sinalizar que Ã© um mÃ³dulo criado no projeto. Importaremos tambÃ©m o mÃ³dulo Express, porÃ©m, dessa vez iniciaremos um roteador, e nÃ£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um mÃ³dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos cÃ³digos que nÃ£o estÃ£o mais sendo usados pelo servidor. EntÃ£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja fÃ¡cil a manutenÃ§Ã£o, ainda nÃ£o Ã© o ideal, mas Ã© o suficiente!\n\nSe vocÃª chegou atÃ© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu prÃ³prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma sÃ©rie de posts envolvendo o desenvolvimento de aplicaÃ§Ãµes Back End e Front End.\n\nDeixe seu comentÃ¡rio dizendo o que estÃ¡ bom e o que Ã© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":[{"title":"PostgreSQL + Docker = ğŸ’™","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, con...","content":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta prÃ¡tica de conteinerizaÃ§Ã£o possibilita uma configuraÃ§Ã£o rÃ¡pida de ambientes de desenvolvimento, testes e produÃ§Ã£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta grÃ¡fica de administraÃ§Ã£o que, por sua vez, tambÃ©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar vÃ¡rios contÃªineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSerÃ¡ demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar contÃªineres a partir de imagens](#clock4-criar-contÃªineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, Ã© esperado que vocÃª tenha conhecimento bÃ¡sico das tecnologias citadas. Certifique-se de que hÃ¡ instalado em sua mÃ¡quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial sÃ£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) sÃ£o pontes de comunicaÃ§Ã£o que possiblitam Ã  contÃªineres uma conexÃ£o entre eles. Geralmente, criasse uma network quando dois ou mias contÃªineres tÃªm uma relaÃ§Ã£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que serÃ¡ utilizada nesse tutorial, Ã© possÃ­vel ver quais outras networks estÃ£o sendo utilizadas em sua mÃ¡quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume Ã© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o contÃªiner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso serÃ¡ criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua mÃ¡quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar contÃªineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar Ã© preciso se atentar Ã  alguns detalhes:\n  \n- Imagens docker sÃ£o construÃ­das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tambÃ©m tÃªm uma versÃ£o, geralmente estes sÃ£o versÃµes do prÃ³prio produto/serviÃ§o escolhido, e caso nÃ£o seja especificado uma versÃ£o sempre serÃ¡ instalado a Ãºltima versÃ£o estÃ¡vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial serÃ¡ usado a imagem do PostgreSQL versÃ£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 vocÃª irÃ¡ usar a Ãºltima versÃ£o estÃ¡vel (mais abaixo). Siga o comando a baixo para criar um contÃªiner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta Ãºnica linha foi criado e executado um contÃªiner, em que:\n  \n- **-\\-name**, especificao nome do contÃªiner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a variÃ¡vel de ambiente do contÃªiner\n  - **POSTGRES_PASSWORD=postgresql**, Ã© a variÃ¡vel de ambiente que especificaa senha necessÃ¡ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta serÃ¡ exposta (**5440:5432**), ou seja, serÃ¡ acessÃ­vel de fora do docker (utilizar em uma aplicaÃ§Ã£o nÃ£o conteinerizada).\n- **-d**, especificaque apÃ³s criado o contÃªiner seu terminal se separe do contÃªiner e vocÃª consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o contÃªiner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o contÃªiner, neste caso a image **postgres**, versÃ£o **12.4** utilizando linux **alpine**.\n  \nÃ‰ possÃ­vel ver outras versÃµes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um contÃªiner utilizando a imagem do pgAdmin4 em sua Ãºltima versÃ£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando Ã© muito parecido com o utilizado para criar o contÃªiner do Postgres. EstÃ£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de variÃ¡veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTambÃ©m, por Ãºltimo se encontra o nome da imagem utilizada para criar o contÃªiner (**dpage/pgadmin4**), como pode ver, desta vez nÃ£o foi passado nenhuma versÃ£o especifica, portanto, por padrÃ£o Ã© instalado a Ãºltima versÃ£o estÃ¡vel da imagem, outro jeito de especificar a Ãºltima versÃ£o da imagem Ã© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJÃ¡ que foi criado os dois contÃªineres Ã© hora de testar se tudo estÃ¡ funcionando como esperado. Primeiro rode o comando abaixo para listar todos os contÃªineres em execuÃ§Ã£o em sua mÃ¡quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois contÃªineres ainda estejam em execuÃ§Ã£o vocÃª deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.sâ€¦\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta Ã© a mesma exposta na criaÃ§Ã£o do contÃªiner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"PÃ¡gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como variÃ¡veis de ambiente na criaÃ§Ã£o do contÃªiner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVocÃª serÃ¡ redirecionado para outra pÃ¡gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"PÃ¡gina inicial pgadmin\" width=\"384px\"/>\n  \nPorÃ©m, ainda nÃ£o hÃ¡ nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o botÃ£o direito em cima do \"Servers\" no canto superior esquerdo, vÃ¡ em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal serÃ¡ aberto onde vocÃª irÃ¡ inserir informaÃ§Ãµes sobre o servidor. No campo \"name\" adicione um nome de sua preferÃªncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do contÃªiner \"**postgres**\" (nome do contÃªiner Postgres).\n- No campo \"Port\" utilize a porta interna do contÃªiner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como estÃ¡.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como variÃ¡vel de ambiente na criaÃ§Ã£o do contÃªiner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no botÃ£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVerÃ¡ que o servidor foi criado e agora vocÃª tem acesso ao banco de dados do mesmo modo se nÃ£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados Ã© o nome do contÃªiner (**postgres**) e a porta Ã© a interna (**5432**). JÃ¡ para acesso externo, como em uma aplicaÃ§Ã£o feita em NodeJS, o host Ã© \"**localhost**\" ou \"**127.0.0.1**\" e a porta Ã© a porta externa especificada na criaÃ§Ã£o do contÃªiner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de criaÃ§Ã£o dos contÃªineres pode ser feito utilizando um arquivo que por convenÃ§Ã£o/padrÃ£o Ã© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, alÃ©m disso adiciona o conceito de **stack**.\n  \nStack nada mais Ã© que um conjunto de contÃªineres que tem uma relaÃ§Ã£o entre si, vocÃª pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack serÃ¡ o nome da pasta em que o arquivo estÃ¡. Ao criar uma network dentro de uma stack o nome desta network terÃ¡ como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para comeÃ§ar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack serÃ¡ **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua preferÃªncia e comece adicionando o bÃ¡sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que hÃ¡:\n  \n- **version** - versÃ£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, serÃ¡ nomeada **postgres-network**, pois serÃ¡ adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do contÃªiner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma Ãºnica linha, serÃ¡ criado um contÃªiner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora Ã© a vez de reescrever script do contÃªiner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTambÃ©m, como no contÃªiner **postgres**, estÃ¡ tudo bem parecido com escrito anteriormente utilizando uma Ãºnica linha. O nome, email, senha, porta e network continuam o mesmo, porÃ©m tambÃ©m foi adicionado um atributo novo, **depends_on**, este permite que o contÃªiner **pgadmin** nÃ£o seja criado/iniciado antes do contÃªiner **postgres** ser criado/iniciado.\n  \nPorÃ©m, antes de executar o arquivo serÃ¡ necessÃ¡rio deletar os contÃªineres jÃ¡ existente afinal nÃ£o serÃ£o mais utilizados como anteriormente, agora eles pertecerÃ£o Ã  uma stack. Primeiro pare os dois contÃªineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os contÃªineres configurados no arquivo sejam criandos, caso ainda nÃ£o exista, e os execute. Ainda, quando algo for alterado no arquivo os contÃªineres afetados serÃ£o reconstruidos.\n  \nEm algum momento, caso vocÃª queira parar todos os contÃªineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, jÃ¡ ter um arquivo/script de instalaÃ§Ã£o econimiza bastante tempo, afinal nÃ£o Ã© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na mÃ£o.\n  \n> O preguiÃ§oso sempre arruma um jeito de nÃ£o ter trabalho.\n  \nPor fim, agradeÃ§o vocÃª por ter chegado atÃ© aqui, deixe seu comentÃ¡rio e sugestÃ£o para os prÃ³ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":["[Circular ~.1]",{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, Ã© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo sÃ£o listados alguns dos conhecimentos que serÃ£o descritos e ensinados neste tutorial:\n\n- Boas prÃ¡ticas de programaÃ§Ã£o\n- DefiniÃ§Ã£o de um sistema de pastas simples e eficiente\n- Iniciar um repositÃ³rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de comeÃ§ar Ã© preciso certificar-se de que alguns programas estÃ£o instalados na mÃ¡quina que serÃ¡ utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execuÃ§Ã£o de cÃ³digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de cÃ³digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de cÃ³digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisiÃ§Ãµes HTTP.\n\nÃ‰ necessÃ¡rio criar uma conta criada no [GitHub](https://github.com/). O GitHub Ã© a plataforma de hospedagem de cÃ³digo-fonte e possui controle de versÃ£o. Essa plataforma poderÃ¡ auxiliar no transporte do cÃ³digo para outro lugar, como para a faculdade ou trabalho.\n\nÃ‰ importante saber o que Ã© um servidor REST, o que Ã© HTTP e como utilizar o Insomnia para fazer requisiÃ§Ãµes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que estÃ¡ sendo montado:\n\n- [O que Ã© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (vÃ­deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir sÃ£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conteÃºdos\n- [Criando pastas](#criando-pastas)\n- [Criando um repositÃ³rio utilizando GitHub](#criando-um-repositÃ³rio-utilizando-github)\n- [Criando um repositÃ³rio sem GitHub](#criando-um-repositÃ³rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [DomÃ­nio](#domÃ­nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [CabeÃ§alhos](#cabeÃ§alhos)\n\t\t- [MÃ©todos](#mÃ©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [ParÃ¢metros (Query String)](#parÃ¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com parÃ¢metros](#get-com-parÃ¢metros)\n\t\t- [GET com rota dinÃ¢mica](#get-com-rota-dinÃ¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara comeÃ§ar serÃ¡ criada uma pasta inicial chamada **server_node**. ApÃ³s criÃ¡-la Ã© necessÃ¡rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois Ã© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto sÃ£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. PorÃ©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estarÃ£o os cÃ³digos que controlaram as funcionalidade do usuÃ¡rio, e outra chamada **db**. Na pasta db estarÃ£o todas a informaÃ§Ã£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas Ã© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os prÃ³ximos passo Ã© necessÃ¡rio que o diretÃ³rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diretÃ³rio atual Ã© **src** dentro de **server_node**. Para voltar diretÃ³rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um repositÃ³rio utilizando GitHub\n\nCaso vocÃª tenha uma conta criada no GitHub, [crie um novo repositÃ³rio](https://github.com/new) com nome **server_node**, sem gitignore, licenÃ§a e readme.\nLogo apÃ³s criado o repositÃ³rio irÃ¡ aparecer algumas opÃ§Ãµes para iniciar o mesmo. Copie todo o conteÃºdo da opÃ§Ã£o **criar um novo repositÃ³rio usando linha de comando**, no meu caso o cÃ³digo Ã© o mostrado abaixo. Cole o conteÃºdo no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conteÃºdo \"# server_node\"\ngit init # inicia um repositÃ³rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu repositÃ³rio para o GitHub\n```\n\n# Criando um repositÃ³rio sem GitHub\n\nCaso vocÃª nÃ£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o cÃ³digo abaixo para iniciar seu versionamento de cÃ³digo local.\n\n```bash\ngit init # inicia repositÃ³rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS Ã© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descriÃ§Ã£o do projeto\n- version, versÃ£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licenÃ§a utilizada no projeto\n- private, se este projeto pode ser publicÃ¡vel ou nÃ£o\n- scripts, comandos de execuÃ§Ã£o\n- dependencies, dependÃªncias principais do projeto\n- devdependencies, dependÃªncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na mÃ£o, Ã© muito mais fÃ¡cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, apÃ³s executar, serÃ¡ necessÃ¡rio preencher alguns dados, como Ã© mostrado abaixo.\n\n```bash\nyarn init # inicia repositÃ³rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes sÃ£o mÃ³dulos, cÃ³digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome jÃ¡ sugere, pacotes principais sÃ£o mÃ³dulos que seu cÃ³digo irÃ¡ precisar mesmo quando em produÃ§Ã£o e pacotes de desenvolvimento sÃ£o mÃ³dulos que vocÃª usarÃ¡ apenas quando estiver programando.\nMÃ³dulos que usaremos sÃ£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplicaÃ§Ã£o faÃ§a requisiÃ§Ã£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisiÃ§Ã£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada alteraÃ§Ã£o no cÃ³digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** Ã© criada, nela estÃ¡ todos os pacotes baixados. Ainda, note que cada vez que vocÃª adiciona ou remove um pacote o arquivo **package.json** Ã© alterado. Isso serve para caso vocÃª precise copiar seu cÃ³digo para outra mÃ¡quina, vocÃª nÃ£o precise copiar a pasta **node_modules** junto, e seja necessÃ¡rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** serÃ£o instalados e automaticamente serÃ¡ criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** serÃ¡ o script para executarmos o servidor em desenvolvimento, reiniciando a cada modificaÃ§Ã£o no cÃ³digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** serÃ¡ o script que utilizaremos quando quisermos executar nosso servidor em produÃ§Ã£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e dependÃªncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de comeÃ§armos a codar precisamos lembrar de alguns conceitos de requisiÃ§Ãµes HTTP.\nPara fazermos uma requisiÃ§Ã£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o domÃ­nio, a porta, a rota, os cabeÃ§alhos (headers), o corpo (body) e os parÃ¢metros (query string).\n\n## DomÃ­nio\n\nDomÃ­nio, de forma bem ampla, Ã© o nome do servidor, este Ã© um jeito utilizado para nÃ£o precisarmos escrever o IP de todo site que quisermos acessar. O domÃ­nio, assim como o IP, Ã© Ãºnico e Ã© reconhecido por toda a internet. Como exemplo, a Google tem um domÃ­nio global `google.com`\nque por trÃ¡s estÃ¡ um IP `172.217.28.78`.\n\nA Ãºnica exceÃ§Ã£o de domÃ­nio e IP que se repete em toda mÃ¡quina Ã© o local. Toda mÃ¡quina mÃ¡quina consegue se acessar usando o domÃ­nio local `localhost` e IP `127.0.0.1`, portanto uma mÃ¡quina nÃ£o consegue acessar um aplicaÃ§Ã£o de outra mÃ¡quina utilizando o domÃ­nio `localhost`, pois ela tentarÃ¡ acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, sÃ£o conexÃµes de cada aplicaÃ§Ã£o dentro da nossa mÃ¡quina. Cada aplicaÃ§Ã£o utiliza uma ou mais portas para se comunicar com outra aplicaÃ§Ã£o, internamente ou nÃ£o. Em nossa mÃ¡quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padrÃ£o HTTP utiliza a porta 80, por isso muita das vezes nÃ£o precisamos explicitamente colocar a porta ao acessar um site.\nFaÃ§a o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso vocÃª conseguirÃ¡ acessar o site, porÃ©m no seguindo caso o navegador nÃ£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, porÃ©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, Ã© o caminho em que o usuÃ¡rio faz uma requisiÃ§Ã£o ao servidor.\nSendo assim, um caminho dita qual conteÃºdo vocÃª espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a pÃ¡gina de busca do site `/` , jÃ¡ no segundo caso pedimos ao servidor do google que nos mostre a pÃ¡gina doodles `/doodles/`.\n\nServidores tÃªm a possibilidade tambÃ©m de criar rotas dinÃ¢micas, estas sÃ£o rotas geradas automaticamente para requisiÃ§Ã£o de um dado especÃ­fico mas que o tratamento desse dado Ã© genÃ©rico. Como, buscar dados de um usuÃ¡rio especÃ­fico. O servidor irÃ¡ retornar os dados apenas daquele usuÃ¡rio, porÃ©m o tratamento no servidor Ã© genÃ©rico, de forma que consiga buscar qualquer usuÃ¡rio dentro do banco de dados.\n\n## CabeÃ§alhos\n\nOs cabeÃ§alhos tÃªm informaÃ§Ãµes importantes sobre o usuÃ¡rio e tambÃ©m sobre o servidor (no retorno).\nNos cabeÃ§alhos conseguimos encontrar o mÃ©todo/verbo da requisiÃ§Ã£o (GET, POST, PUT, DELETE, entre outros), o tipo do conteÃºdo da requisiÃ§Ã£o, o tamanho do conteÃºdo enviado na requisiÃ§Ã£o, qual aplicaÃ§Ã£o fez a requisiÃ§Ã£o, o domÃ­nio em que o usuÃ¡rio estÃ¡, entre outros.\n\n### MÃ©todos\n\nComo dito antes, nos cabeÃ§alhos Ã© possÃ­vel encontrar o mÃ©todo/verbo da requisiÃ§Ã£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conteÃºdos do cabeÃ§alho, no servidores com **Express** sempre precisamos falar quais mÃ©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padrÃ£o utilizam apenas os mÃ©todos GET e POST, portanto, para utilizar outro mÃ©todo Ã© necessÃ¡rio utilizar JavaScript em uma requisiÃ§Ã£o.\n\n#### GET\n\nPor padrÃ£o Ã© utilizado quando queremos apenas o retorno de algum dado/pÃ¡gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usuÃ¡rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor, porÃ©m, desta vez estamos modificando um dado jÃ¡ existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo Ã© um espaÃ§o na requisiÃ§Ã£o HTTP onde os dados de um formulÃ¡rio sÃ£o enviados ao servidor. HÃ¡ vÃ¡rios tipos de conteÃºdos que podem ser enviados no corpo, por isso do campo `tipo de contÃ©udo` dentro dos cabeÃ§alhos.\n\n## ParÃ¢metros (Query String)\n\nParÃ¢metros, como o nome jÃ¡ indica, sÃ£o parÃ¢metros que passamos junto a rota, geralmente sÃ£o utilizados como filtros para alguma requisiÃ§Ã£o.\n\nUm exemplo de parÃ¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um parÃ¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais parÃ¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os parÃ¢metros sÃ£o utilizados junto ao mÃ©todo GET, para filtragem de resultados no servidor. PorÃ©m nada impede de ser usados junto a outro mÃ©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- MÃ©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com parÃ¢metros\n\n- MÃ©todo: GET\n- Rota: /nomes\n- ParÃ¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho mÃ¡ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota dinÃ¢mica\n\n- MÃ©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informaÃ§Ãµes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- MÃ©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- MÃ©todo: PUT\n- Rota dinÃ¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- MÃ©todo: DELETE\n- Rota dinÃ¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso repositÃ³rio, iniciamos o projeto com Yarn, instalamos alguns mÃ³dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisiÃ§Ã£o HTTP.\n\nAgora estamos prontos para ir para a prÃ³xima fase, onde realmente colocamos a mÃ£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de vocÃª ter chegado atÃ© aqui! Espero que eu tenha lhe passado algum conhecimento. EntÃ£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":["[Circular ~.1.suggestions.0]","[Circular ~.1]"]}]},{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, Ã© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo sÃ£o listados alguns dos conhecimentos que serÃ£o descritos e ensinados neste tutorial:\n\n- Boas prÃ¡ticas de programaÃ§Ã£o\n- DefiniÃ§Ã£o de um sistema de pastas simples e eficiente\n- Iniciar um repositÃ³rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de comeÃ§ar Ã© preciso certificar-se de que alguns programas estÃ£o instalados na mÃ¡quina que serÃ¡ utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execuÃ§Ã£o de cÃ³digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de cÃ³digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de cÃ³digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisiÃ§Ãµes HTTP.\n\nÃ‰ necessÃ¡rio criar uma conta criada no [GitHub](https://github.com/). O GitHub Ã© a plataforma de hospedagem de cÃ³digo-fonte e possui controle de versÃ£o. Essa plataforma poderÃ¡ auxiliar no transporte do cÃ³digo para outro lugar, como para a faculdade ou trabalho.\n\nÃ‰ importante saber o que Ã© um servidor REST, o que Ã© HTTP e como utilizar o Insomnia para fazer requisiÃ§Ãµes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que estÃ¡ sendo montado:\n\n- [O que Ã© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (vÃ­deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir sÃ£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conteÃºdos\n- [Criando pastas](#criando-pastas)\n- [Criando um repositÃ³rio utilizando GitHub](#criando-um-repositÃ³rio-utilizando-github)\n- [Criando um repositÃ³rio sem GitHub](#criando-um-repositÃ³rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [DomÃ­nio](#domÃ­nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [CabeÃ§alhos](#cabeÃ§alhos)\n\t\t- [MÃ©todos](#mÃ©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [ParÃ¢metros (Query String)](#parÃ¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com parÃ¢metros](#get-com-parÃ¢metros)\n\t\t- [GET com rota dinÃ¢mica](#get-com-rota-dinÃ¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara comeÃ§ar serÃ¡ criada uma pasta inicial chamada **server_node**. ApÃ³s criÃ¡-la Ã© necessÃ¡rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois Ã© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto sÃ£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. PorÃ©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estarÃ£o os cÃ³digos que controlaram as funcionalidade do usuÃ¡rio, e outra chamada **db**. Na pasta db estarÃ£o todas a informaÃ§Ã£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas Ã© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os prÃ³ximos passo Ã© necessÃ¡rio que o diretÃ³rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diretÃ³rio atual Ã© **src** dentro de **server_node**. Para voltar diretÃ³rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um repositÃ³rio utilizando GitHub\n\nCaso vocÃª tenha uma conta criada no GitHub, [crie um novo repositÃ³rio](https://github.com/new) com nome **server_node**, sem gitignore, licenÃ§a e readme.\nLogo apÃ³s criado o repositÃ³rio irÃ¡ aparecer algumas opÃ§Ãµes para iniciar o mesmo. Copie todo o conteÃºdo da opÃ§Ã£o **criar um novo repositÃ³rio usando linha de comando**, no meu caso o cÃ³digo Ã© o mostrado abaixo. Cole o conteÃºdo no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conteÃºdo \"# server_node\"\ngit init # inicia um repositÃ³rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu repositÃ³rio para o GitHub\n```\n\n# Criando um repositÃ³rio sem GitHub\n\nCaso vocÃª nÃ£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o cÃ³digo abaixo para iniciar seu versionamento de cÃ³digo local.\n\n```bash\ngit init # inicia repositÃ³rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS Ã© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descriÃ§Ã£o do projeto\n- version, versÃ£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licenÃ§a utilizada no projeto\n- private, se este projeto pode ser publicÃ¡vel ou nÃ£o\n- scripts, comandos de execuÃ§Ã£o\n- dependencies, dependÃªncias principais do projeto\n- devdependencies, dependÃªncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na mÃ£o, Ã© muito mais fÃ¡cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, apÃ³s executar, serÃ¡ necessÃ¡rio preencher alguns dados, como Ã© mostrado abaixo.\n\n```bash\nyarn init # inicia repositÃ³rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes sÃ£o mÃ³dulos, cÃ³digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome jÃ¡ sugere, pacotes principais sÃ£o mÃ³dulos que seu cÃ³digo irÃ¡ precisar mesmo quando em produÃ§Ã£o e pacotes de desenvolvimento sÃ£o mÃ³dulos que vocÃª usarÃ¡ apenas quando estiver programando.\nMÃ³dulos que usaremos sÃ£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplicaÃ§Ã£o faÃ§a requisiÃ§Ã£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisiÃ§Ã£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada alteraÃ§Ã£o no cÃ³digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** Ã© criada, nela estÃ¡ todos os pacotes baixados. Ainda, note que cada vez que vocÃª adiciona ou remove um pacote o arquivo **package.json** Ã© alterado. Isso serve para caso vocÃª precise copiar seu cÃ³digo para outra mÃ¡quina, vocÃª nÃ£o precise copiar a pasta **node_modules** junto, e seja necessÃ¡rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** serÃ£o instalados e automaticamente serÃ¡ criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** serÃ¡ o script para executarmos o servidor em desenvolvimento, reiniciando a cada modificaÃ§Ã£o no cÃ³digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** serÃ¡ o script que utilizaremos quando quisermos executar nosso servidor em produÃ§Ã£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e dependÃªncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de comeÃ§armos a codar precisamos lembrar de alguns conceitos de requisiÃ§Ãµes HTTP.\nPara fazermos uma requisiÃ§Ã£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o domÃ­nio, a porta, a rota, os cabeÃ§alhos (headers), o corpo (body) e os parÃ¢metros (query string).\n\n## DomÃ­nio\n\nDomÃ­nio, de forma bem ampla, Ã© o nome do servidor, este Ã© um jeito utilizado para nÃ£o precisarmos escrever o IP de todo site que quisermos acessar. O domÃ­nio, assim como o IP, Ã© Ãºnico e Ã© reconhecido por toda a internet. Como exemplo, a Google tem um domÃ­nio global `google.com`\nque por trÃ¡s estÃ¡ um IP `172.217.28.78`.\n\nA Ãºnica exceÃ§Ã£o de domÃ­nio e IP que se repete em toda mÃ¡quina Ã© o local. Toda mÃ¡quina mÃ¡quina consegue se acessar usando o domÃ­nio local `localhost` e IP `127.0.0.1`, portanto uma mÃ¡quina nÃ£o consegue acessar um aplicaÃ§Ã£o de outra mÃ¡quina utilizando o domÃ­nio `localhost`, pois ela tentarÃ¡ acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, sÃ£o conexÃµes de cada aplicaÃ§Ã£o dentro da nossa mÃ¡quina. Cada aplicaÃ§Ã£o utiliza uma ou mais portas para se comunicar com outra aplicaÃ§Ã£o, internamente ou nÃ£o. Em nossa mÃ¡quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padrÃ£o HTTP utiliza a porta 80, por isso muita das vezes nÃ£o precisamos explicitamente colocar a porta ao acessar um site.\nFaÃ§a o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso vocÃª conseguirÃ¡ acessar o site, porÃ©m no seguindo caso o navegador nÃ£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, porÃ©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, Ã© o caminho em que o usuÃ¡rio faz uma requisiÃ§Ã£o ao servidor.\nSendo assim, um caminho dita qual conteÃºdo vocÃª espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a pÃ¡gina de busca do site `/` , jÃ¡ no segundo caso pedimos ao servidor do google que nos mostre a pÃ¡gina doodles `/doodles/`.\n\nServidores tÃªm a possibilidade tambÃ©m de criar rotas dinÃ¢micas, estas sÃ£o rotas geradas automaticamente para requisiÃ§Ã£o de um dado especÃ­fico mas que o tratamento desse dado Ã© genÃ©rico. Como, buscar dados de um usuÃ¡rio especÃ­fico. O servidor irÃ¡ retornar os dados apenas daquele usuÃ¡rio, porÃ©m o tratamento no servidor Ã© genÃ©rico, de forma que consiga buscar qualquer usuÃ¡rio dentro do banco de dados.\n\n## CabeÃ§alhos\n\nOs cabeÃ§alhos tÃªm informaÃ§Ãµes importantes sobre o usuÃ¡rio e tambÃ©m sobre o servidor (no retorno).\nNos cabeÃ§alhos conseguimos encontrar o mÃ©todo/verbo da requisiÃ§Ã£o (GET, POST, PUT, DELETE, entre outros), o tipo do conteÃºdo da requisiÃ§Ã£o, o tamanho do conteÃºdo enviado na requisiÃ§Ã£o, qual aplicaÃ§Ã£o fez a requisiÃ§Ã£o, o domÃ­nio em que o usuÃ¡rio estÃ¡, entre outros.\n\n### MÃ©todos\n\nComo dito antes, nos cabeÃ§alhos Ã© possÃ­vel encontrar o mÃ©todo/verbo da requisiÃ§Ã£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conteÃºdos do cabeÃ§alho, no servidores com **Express** sempre precisamos falar quais mÃ©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padrÃ£o utilizam apenas os mÃ©todos GET e POST, portanto, para utilizar outro mÃ©todo Ã© necessÃ¡rio utilizar JavaScript em uma requisiÃ§Ã£o.\n\n#### GET\n\nPor padrÃ£o Ã© utilizado quando queremos apenas o retorno de algum dado/pÃ¡gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usuÃ¡rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor, porÃ©m, desta vez estamos modificando um dado jÃ¡ existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo Ã© um espaÃ§o na requisiÃ§Ã£o HTTP onde os dados de um formulÃ¡rio sÃ£o enviados ao servidor. HÃ¡ vÃ¡rios tipos de conteÃºdos que podem ser enviados no corpo, por isso do campo `tipo de contÃ©udo` dentro dos cabeÃ§alhos.\n\n## ParÃ¢metros (Query String)\n\nParÃ¢metros, como o nome jÃ¡ indica, sÃ£o parÃ¢metros que passamos junto a rota, geralmente sÃ£o utilizados como filtros para alguma requisiÃ§Ã£o.\n\nUm exemplo de parÃ¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um parÃ¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais parÃ¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os parÃ¢metros sÃ£o utilizados junto ao mÃ©todo GET, para filtragem de resultados no servidor. PorÃ©m nada impede de ser usados junto a outro mÃ©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- MÃ©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com parÃ¢metros\n\n- MÃ©todo: GET\n- Rota: /nomes\n- ParÃ¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho mÃ¡ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota dinÃ¢mica\n\n- MÃ©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informaÃ§Ãµes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- MÃ©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- MÃ©todo: PUT\n- Rota dinÃ¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- MÃ©todo: DELETE\n- Rota dinÃ¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso repositÃ³rio, iniciamos o projeto com Yarn, instalamos alguns mÃ³dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisiÃ§Ã£o HTTP.\n\nAgora estamos prontos para ir para a prÃ³xima fase, onde realmente colocamos a mÃ£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de vocÃª ter chegado atÃ© aqui! Espero que eu tenha lhe passado algum conhecimento. EntÃ£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":[{"title":"PostgreSQL + Docker = ğŸ’™","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, con...","content":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta prÃ¡tica de conteinerizaÃ§Ã£o possibilita uma configuraÃ§Ã£o rÃ¡pida de ambientes de desenvolvimento, testes e produÃ§Ã£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta grÃ¡fica de administraÃ§Ã£o que, por sua vez, tambÃ©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar vÃ¡rios contÃªineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSerÃ¡ demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar contÃªineres a partir de imagens](#clock4-criar-contÃªineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, Ã© esperado que vocÃª tenha conhecimento bÃ¡sico das tecnologias citadas. Certifique-se de que hÃ¡ instalado em sua mÃ¡quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial sÃ£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) sÃ£o pontes de comunicaÃ§Ã£o que possiblitam Ã  contÃªineres uma conexÃ£o entre eles. Geralmente, criasse uma network quando dois ou mias contÃªineres tÃªm uma relaÃ§Ã£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que serÃ¡ utilizada nesse tutorial, Ã© possÃ­vel ver quais outras networks estÃ£o sendo utilizadas em sua mÃ¡quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume Ã© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o contÃªiner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso serÃ¡ criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua mÃ¡quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar contÃªineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar Ã© preciso se atentar Ã  alguns detalhes:\n  \n- Imagens docker sÃ£o construÃ­das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tambÃ©m tÃªm uma versÃ£o, geralmente estes sÃ£o versÃµes do prÃ³prio produto/serviÃ§o escolhido, e caso nÃ£o seja especificado uma versÃ£o sempre serÃ¡ instalado a Ãºltima versÃ£o estÃ¡vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial serÃ¡ usado a imagem do PostgreSQL versÃ£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 vocÃª irÃ¡ usar a Ãºltima versÃ£o estÃ¡vel (mais abaixo). Siga o comando a baixo para criar um contÃªiner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta Ãºnica linha foi criado e executado um contÃªiner, em que:\n  \n- **-\\-name**, especificao nome do contÃªiner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a variÃ¡vel de ambiente do contÃªiner\n  - **POSTGRES_PASSWORD=postgresql**, Ã© a variÃ¡vel de ambiente que especificaa senha necessÃ¡ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta serÃ¡ exposta (**5440:5432**), ou seja, serÃ¡ acessÃ­vel de fora do docker (utilizar em uma aplicaÃ§Ã£o nÃ£o conteinerizada).\n- **-d**, especificaque apÃ³s criado o contÃªiner seu terminal se separe do contÃªiner e vocÃª consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o contÃªiner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o contÃªiner, neste caso a image **postgres**, versÃ£o **12.4** utilizando linux **alpine**.\n  \nÃ‰ possÃ­vel ver outras versÃµes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um contÃªiner utilizando a imagem do pgAdmin4 em sua Ãºltima versÃ£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando Ã© muito parecido com o utilizado para criar o contÃªiner do Postgres. EstÃ£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de variÃ¡veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTambÃ©m, por Ãºltimo se encontra o nome da imagem utilizada para criar o contÃªiner (**dpage/pgadmin4**), como pode ver, desta vez nÃ£o foi passado nenhuma versÃ£o especifica, portanto, por padrÃ£o Ã© instalado a Ãºltima versÃ£o estÃ¡vel da imagem, outro jeito de especificar a Ãºltima versÃ£o da imagem Ã© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJÃ¡ que foi criado os dois contÃªineres Ã© hora de testar se tudo estÃ¡ funcionando como esperado. Primeiro rode o comando abaixo para listar todos os contÃªineres em execuÃ§Ã£o em sua mÃ¡quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois contÃªineres ainda estejam em execuÃ§Ã£o vocÃª deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.sâ€¦\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta Ã© a mesma exposta na criaÃ§Ã£o do contÃªiner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"PÃ¡gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como variÃ¡veis de ambiente na criaÃ§Ã£o do contÃªiner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVocÃª serÃ¡ redirecionado para outra pÃ¡gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"PÃ¡gina inicial pgadmin\" width=\"384px\"/>\n  \nPorÃ©m, ainda nÃ£o hÃ¡ nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o botÃ£o direito em cima do \"Servers\" no canto superior esquerdo, vÃ¡ em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal serÃ¡ aberto onde vocÃª irÃ¡ inserir informaÃ§Ãµes sobre o servidor. No campo \"name\" adicione um nome de sua preferÃªncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do contÃªiner \"**postgres**\" (nome do contÃªiner Postgres).\n- No campo \"Port\" utilize a porta interna do contÃªiner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como estÃ¡.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como variÃ¡vel de ambiente na criaÃ§Ã£o do contÃªiner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no botÃ£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVerÃ¡ que o servidor foi criado e agora vocÃª tem acesso ao banco de dados do mesmo modo se nÃ£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados Ã© o nome do contÃªiner (**postgres**) e a porta Ã© a interna (**5432**). JÃ¡ para acesso externo, como em uma aplicaÃ§Ã£o feita em NodeJS, o host Ã© \"**localhost**\" ou \"**127.0.0.1**\" e a porta Ã© a porta externa especificada na criaÃ§Ã£o do contÃªiner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de criaÃ§Ã£o dos contÃªineres pode ser feito utilizando um arquivo que por convenÃ§Ã£o/padrÃ£o Ã© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, alÃ©m disso adiciona o conceito de **stack**.\n  \nStack nada mais Ã© que um conjunto de contÃªineres que tem uma relaÃ§Ã£o entre si, vocÃª pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack serÃ¡ o nome da pasta em que o arquivo estÃ¡. Ao criar uma network dentro de uma stack o nome desta network terÃ¡ como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para comeÃ§ar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack serÃ¡ **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua preferÃªncia e comece adicionando o bÃ¡sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que hÃ¡:\n  \n- **version** - versÃ£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, serÃ¡ nomeada **postgres-network**, pois serÃ¡ adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do contÃªiner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma Ãºnica linha, serÃ¡ criado um contÃªiner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora Ã© a vez de reescrever script do contÃªiner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTambÃ©m, como no contÃªiner **postgres**, estÃ¡ tudo bem parecido com escrito anteriormente utilizando uma Ãºnica linha. O nome, email, senha, porta e network continuam o mesmo, porÃ©m tambÃ©m foi adicionado um atributo novo, **depends_on**, este permite que o contÃªiner **pgadmin** nÃ£o seja criado/iniciado antes do contÃªiner **postgres** ser criado/iniciado.\n  \nPorÃ©m, antes de executar o arquivo serÃ¡ necessÃ¡rio deletar os contÃªineres jÃ¡ existente afinal nÃ£o serÃ£o mais utilizados como anteriormente, agora eles pertecerÃ£o Ã  uma stack. Primeiro pare os dois contÃªineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os contÃªineres configurados no arquivo sejam criandos, caso ainda nÃ£o exista, e os execute. Ainda, quando algo for alterado no arquivo os contÃªineres afetados serÃ£o reconstruidos.\n  \nEm algum momento, caso vocÃª queira parar todos os contÃªineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, jÃ¡ ter um arquivo/script de instalaÃ§Ã£o econimiza bastante tempo, afinal nÃ£o Ã© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na mÃ£o.\n  \n> O preguiÃ§oso sempre arruma um jeito de nÃ£o ter trabalho.\n  \nPor fim, agradeÃ§o vocÃª por ter chegado atÃ© aqui, deixe seu comentÃ¡rio e sugestÃ£o para os prÃ³ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":["[Circular ~.1]","[Circular ~.1.suggestions.1]"]},"[Circular ~.1]"]}]},{"title":"Criando um servidor em NodeJS - Parte 1","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f","slug":"criando-um-servidor-em-nodejs-parte-1-c7f","description":"Este tutorial, dividido em duas partes (Parte 2),  ensina como iniciar um servidor Rest API em NodeJS...","content":"Este tutorial, dividido em duas partes ([Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7)),  ensina como iniciar um servidor Rest API em NodeJS da forma mais trivial. Dessa forma, Ã© utilizado apenas um arquivo JSON, dispensando o uso de sistema gerenciador de banco de dados. Assim, este artigo tem o objetivo de auxiliar programadores iniciantes.\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\nAbaixo sÃ£o listados alguns dos conhecimentos que serÃ£o descritos e ensinados neste tutorial:\n\n- Boas prÃ¡ticas de programaÃ§Ã£o\n- DefiniÃ§Ã£o de um sistema de pastas simples e eficiente\n- Iniciar um repositÃ³rio Git\n- Iniciar um projeto Node utilizando yarn\n- Ler e manipular arquivos usando Node\n- Criar um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr> (Criar, Ler, Alterar e Deletar) simples\n- Usar o prompt de comando/terminal\n\nAntes de comeÃ§ar Ã© preciso certificar-se de que alguns programas estÃ£o instalados na mÃ¡quina que serÃ¡ utilizada para realizar este tutorial.\n\n- [NodeJS](https://nodejs.org/en/download/), ambiente de execuÃ§Ã£o de cÃ³digo JavaScript. Este programa permite executar JavaScript fora do navegador.\n- [Yarn](https://classic.yarnpkg.com/en/docs/install), gerenciador de pacotes JavaScript.\n- [Git](https://git-scm.com/), versionador de cÃ³digo.\n- [Visual Studio Code](https://code.visualstudio.com/), editor de cÃ³digo.\n- [Insomnia](https://insomnia.rest/), ambiente para testar requisiÃ§Ãµes HTTP.\n\nÃ‰ necessÃ¡rio criar uma conta criada no [GitHub](https://github.com/). O GitHub Ã© a plataforma de hospedagem de cÃ³digo-fonte e possui controle de versÃ£o. Essa plataforma poderÃ¡ auxiliar no transporte do cÃ³digo para outro lugar, como para a faculdade ou trabalho.\n\nÃ‰ importante saber o que Ã© um servidor REST, o que Ã© HTTP e como utilizar o Insomnia para fazer requisiÃ§Ãµes ao servidor HTTP. Para isso foram separados alguns links demonstrar o que estÃ¡ sendo montado:\n\n- [O que Ã© API Rest e Restful?](https://becode.com.br/o-que-e-api-rest-e-restful/) (post)\n- [ENTENDENDO O PROTOCOLO HTTP](http://blog.leandrocurioso.com/2017/05/entendendo-o-protocolo-http/) (post)\n- [Insomnia](https://www.youtube.com/watch?v=3tB0uDliS6Y) (vÃ­deo).\n\nIniciando o projeto.\n\nLembrando que os passos a seguir sÃ£o realizados em um terminal bash, o mesmo utilizado em sistemas operacionais Linux.\n\n## Tabela de conteÃºdos\n- [Criando pastas](#criando-pastas)\n- [Criando um repositÃ³rio utilizando GitHub](#criando-um-repositÃ³rio-utilizando-github)\n- [Criando um repositÃ³rio sem GitHub](#criando-um-repositÃ³rio-sem-github)\n- [Criando package.json usando Yarn](#criando-packagejson-usando-yarn)\n\t- [Instalando os primeiros pacotes](#instalando-os-primeiros-pacotes)\n\t- [Scripts](#scripts)\n- [REST com Express](#rest-com-express)\n\t- [DomÃ­nio](#domÃ­nio)\n\t- [Porta](#porta)\n\t- [Rota](#rota)\n\t- [CabeÃ§alhos](#cabeÃ§alhos)\n\t\t- [MÃ©todos](#mÃ©todos)\n\t\t\t- [GET](#get)\n\t\t\t- [POST](#post)\n\t\t\t- [PUT](#put)\n\t\t\t- [DELETE](#delete)\n\t- [Corpo](#corpo)\n\t- [ParÃ¢metros (Query String)](#parÃ¢metros-query-string)\n\t- [Recapitulando REST com Express](#recapitulando-rest-com-express)\n\t\t- [GET](#get-1)\n\t\t- [GET com parÃ¢metros](#get-com-parÃ¢metros)\n\t\t- [GET com rota dinÃ¢mica](#get-com-rota-dinÃ¢mica)\n\t\t- [POST](#post-1)\n\t\t- [PUT](#put-1)\n\t\t- [DELETE](#delete-1)\n- [Recapitulando](#recapitulando)\n\n# Criando pastas\n\nPara comeÃ§ar serÃ¡ criada uma pasta inicial chamada **server_node**. ApÃ³s criÃ¡-la Ã© necessÃ¡rio entrar nela\n\n```bash\nmkdir server_node # cria pasta server_node\ncd server_node # entra na pasta\n```\n\nDepois Ã© criada uma pasta chamada **src**. Nessa pasta todos os arquivos de desenvolvimento do projeto sÃ£o depositados.\n\n```bash\nmkdir src # cria pasta src\ncd src # entra na pasta\n```\n\nPor enquanto, tem-se apenas a pasta **server_node** e dentro dela uma pasta chamada **src**. PorÃ©m, dentro da pasta **src** ainda deve ser criada uma hierarquia de pastas.\n\nUma pasta chamada **controllers**, na qual estarÃ£o os cÃ³digos que controlaram as funcionalidade do usuÃ¡rio, e outra chamada **db**. Na pasta db estarÃ£o todas a informaÃ§Ã£o do base de dados, neste caso um arquivo .json com alguns dados.\n\nPara criar essas pastas Ã© executado o seguinte comando:\n\n```bash\nmkdir controllers db # cria as duas pastas em uma linha\n```\n\nPara os prÃ³ximos passo Ã© necessÃ¡rio que o diretÃ³rio atual seja a **raiz** do projeto, ou seja, a pasta **server_node**. Lembrando que o diretÃ³rio atual Ã© **src** dentro de **server_node**. Para voltar diretÃ³rios execute.\n\n```bash\ncd ../ # volta uma pasta\n```\n\n# Criando um repositÃ³rio utilizando GitHub\n\nCaso vocÃª tenha uma conta criada no GitHub, [crie um novo repositÃ³rio](https://github.com/new) com nome **server_node**, sem gitignore, licenÃ§a e readme.\nLogo apÃ³s criado o repositÃ³rio irÃ¡ aparecer algumas opÃ§Ãµes para iniciar o mesmo. Copie todo o conteÃºdo da opÃ§Ã£o **criar um novo repositÃ³rio usando linha de comando**, no meu caso o cÃ³digo Ã© o mostrado abaixo. Cole o conteÃºdo no terminal e de enter.\n\n```bash\necho \"# server_node\" >> README.md # cria um arquivo com o conteÃºdo \"# server_node\"\ngit init # inicia um repositÃ³rio git local\ngit add README.md # adiciona o arquivo ao commit\ngit commit -m \"first commit\" # adiciona uma mensagem ao commit\ngit remote add origin https://github.com/devbaraus/server_node.git # vincula o repositorio do github ao seu repositorio local\ngit push -u origin master # envia o estado atual do seu repositÃ³rio para o GitHub\n```\n\n# Criando um repositÃ³rio sem GitHub\n\nCaso vocÃª nÃ£o utilize o GitHub ou qualquer outra plataforma. Apenas copie e cole o cÃ³digo abaixo para iniciar seu versionamento de cÃ³digo local.\n\n```bash\ngit init # inicia repositÃ³rio git local\n```\n\nPronto!\n\n# Criando package.json usando Yarn\n\nPara iniciarmos um projeto NodeJS Ã© muito simples, apenas precisamos criar um arquivo chamado **package.json** com algumas propriedades, como:\n\n- name, nome do projeto\n- description, descriÃ§Ã£o do projeto\n- version, versÃ£o atual do projeto\n- main, arquivo principal do projeto\n- author, autor do projeto\n- license, licenÃ§a utilizada no projeto\n- private, se este projeto pode ser publicÃ¡vel ou nÃ£o\n- scripts, comandos de execuÃ§Ã£o\n- dependencies, dependÃªncias principais do projeto\n- devdependencies, dependÃªncias apenas utilizadas no desenvolvimento\n\nEmbora seja algo simples de se criar na mÃ£o, Ã© muito mais fÃ¡cil utilizando um comando que o Yarn disponibiliza. Este comando se chama **yarn init**, apÃ³s executar, serÃ¡ necessÃ¡rio preencher alguns dados, como Ã© mostrado abaixo.\n\n```bash\nyarn init # inicia repositÃ³rio git local\n```\n\n```\nquestion name (server_node):\nquestion version (1.0.0): 0.0.1\nquestion description: Servidor em nodejs\nquestion respository url: https://github.com/devbaraus/post_server_node.git\nquestion author: Bruno de Araujo Alves <devbaraus>\nquestion license (MIT): MIT\nquestion private: false\n```\n\nPreenchido todos os comandos seu arquivo deve se parecer como o mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_sxzlrk.png\" title=\"package.json\" width=\"384px\">\n</p>\n\n## Instalando os primeiros pacotes\n\nPacotes sÃ£o mÃ³dulos, cÃ³digos que outras pessoas fizeram para realizar alguma coisa.\nNeste projeto utilizaremos poucos pacotes, sendo eles classificados em principais ou desenvolvimento. Como o nome jÃ¡ sugere, pacotes principais sÃ£o mÃ³dulos que seu cÃ³digo irÃ¡ precisar mesmo quando em produÃ§Ã£o e pacotes de desenvolvimento sÃ£o mÃ³dulos que vocÃª usarÃ¡ apenas quando estiver programando.\nMÃ³dulos que usaremos sÃ£o:\n\nPrincipais\n\n- Express, possibilita criarmos um servidor http utilizando node\n- cors, possibilita que uma outra aplicaÃ§Ã£o faÃ§a requisiÃ§Ã£o ao seu servidor\n\nPara instalar use\n\n```bash\nyarn add Express cors\n```\n\nDesenvolvimento\n\n- morgan, possiblita gerar logs de toda requisiÃ§Ã£o feita ao servidor\n- nodemon, possibilita que executemos nosso servidor e a cada alteraÃ§Ã£o no cÃ³digo o servidor seja reiniciado.\n\nE para instalar os pacotes em modo de desenvolvimento, apenas adicione mais um argumento **-D** .\n\n```bash\nyarn -D add morgan nodemon\n```\n\nSeu package.json deve estar semelhante a este.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json_dependencies_da9zho.png\" title=\"package.json com dependencias\" width=\"384px\">\n</p>\n\nSe atente que ao instalar um novo pacote uma pasta chamada **node_modules** Ã© criada, nela estÃ¡ todos os pacotes baixados. Ainda, note que cada vez que vocÃª adiciona ou remove um pacote o arquivo **package.json** Ã© alterado. Isso serve para caso vocÃª precise copiar seu cÃ³digo para outra mÃ¡quina, vocÃª nÃ£o precise copiar a pasta **node_modules** junto, e seja necessÃ¡rio apenas executar o comando.\n\n```bash\nyarn install # instala todos os pacotes do package.json\n```\n\nCom esse comando todos os pacotes que estejam no **package.json** serÃ£o instalados e automaticamente serÃ¡ criada a pasta **node_modules**.\n\n## Scripts\n\nAgora que temos os pacotes instalados podemos criar alguns scripts para executar nosso servidor. Primeiro vamos criar uma nova propriedade no arquivo **package.json** chamada **scripts** e esta receber um objeto vazio.\n\n```json\n\"scripts\": {},\n```\n\nDentro de **scripts** vamos criar duas propriedades, **dev** e **start**.\n**Dev** serÃ¡ o script para executarmos o servidor em desenvolvimento, reiniciando a cada modificaÃ§Ã£o no cÃ³digo.\n\n```json\n\"scripts\": {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\"\n},\n```\n\nE o **start** serÃ¡ o script que utilizaremos quando quisermos executar nosso servidor em produÃ§Ã£o.\n\n```json\n\"scripts\":  {\n\t\"dev\":  \"nodemon --watch ./src/**/* ./src/server\",\n\t\"start\":  \"node ./src/server\"\n},\n```\n\nSeu package.json agora deve estar semelhante ao mostrado abaixo.\n\n<p align=\"center\">\n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1598310567/public/posts/server_node/package_json2_nxyxwo.png\" title=\"package.json com scripts e dependÃªncias\" width=\"384px\">\n</p>\n\n# REST com Express\n\nAntes de comeÃ§armos a codar precisamos lembrar de alguns conceitos de requisiÃ§Ãµes HTTP.\nPara fazermos uma requisiÃ§Ã£o HTTP com **Express** precisamos lembrar de 6 pontos principais: o domÃ­nio, a porta, a rota, os cabeÃ§alhos (headers), o corpo (body) e os parÃ¢metros (query string).\n\n## DomÃ­nio\n\nDomÃ­nio, de forma bem ampla, Ã© o nome do servidor, este Ã© um jeito utilizado para nÃ£o precisarmos escrever o IP de todo site que quisermos acessar. O domÃ­nio, assim como o IP, Ã© Ãºnico e Ã© reconhecido por toda a internet. Como exemplo, a Google tem um domÃ­nio global `google.com`\nque por trÃ¡s estÃ¡ um IP `172.217.28.78`.\n\nA Ãºnica exceÃ§Ã£o de domÃ­nio e IP que se repete em toda mÃ¡quina Ã© o local. Toda mÃ¡quina mÃ¡quina consegue se acessar usando o domÃ­nio local `localhost` e IP `127.0.0.1`, portanto uma mÃ¡quina nÃ£o consegue acessar um aplicaÃ§Ã£o de outra mÃ¡quina utilizando o domÃ­nio `localhost`, pois ela tentarÃ¡ acessar a si mesma.\n\n## Porta\n\nPorta, de forma ampla, sÃ£o conexÃµes de cada aplicaÃ§Ã£o dentro da nossa mÃ¡quina. Cada aplicaÃ§Ã£o utiliza uma ou mais portas para se comunicar com outra aplicaÃ§Ã£o, internamente ou nÃ£o. Em nossa mÃ¡quina temos 65535 portas, sendo 1024 reservados para uso do computador.\n\nLembrando que por padrÃ£o HTTP utiliza a porta 80, por isso muita das vezes nÃ£o precisamos explicitamente colocar a porta ao acessar um site.\nFaÃ§a o teste, acesse `google.com:80` e depois `google.com:82`. No primeiro caso vocÃª conseguirÃ¡ acessar o site, porÃ©m no seguindo caso o navegador nÃ£o conseguira acessar nada.\n\nNesse projeto, nosso servidor utilizamos a porta 3000, porÃ©m pode ser alterado para qualquer valor entre 1024 e 65335.\n\n## Rota\n\nRota, Ã© o caminho em que o usuÃ¡rio faz uma requisiÃ§Ã£o ao servidor.\nSendo assim, um caminho dita qual conteÃºdo vocÃª espera que o servidor te retorne.\nComo exemplo novamente a Google: `google.com/` e`google.com/doodles/`\nNo primeiro caso falamos ao servidor que esperamos a pÃ¡gina de busca do site `/` , jÃ¡ no segundo caso pedimos ao servidor do google que nos mostre a pÃ¡gina doodles `/doodles/`.\n\nServidores tÃªm a possibilidade tambÃ©m de criar rotas dinÃ¢micas, estas sÃ£o rotas geradas automaticamente para requisiÃ§Ã£o de um dado especÃ­fico mas que o tratamento desse dado Ã© genÃ©rico. Como, buscar dados de um usuÃ¡rio especÃ­fico. O servidor irÃ¡ retornar os dados apenas daquele usuÃ¡rio, porÃ©m o tratamento no servidor Ã© genÃ©rico, de forma que consiga buscar qualquer usuÃ¡rio dentro do banco de dados.\n\n## CabeÃ§alhos\n\nOs cabeÃ§alhos tÃªm informaÃ§Ãµes importantes sobre o usuÃ¡rio e tambÃ©m sobre o servidor (no retorno).\nNos cabeÃ§alhos conseguimos encontrar o mÃ©todo/verbo da requisiÃ§Ã£o (GET, POST, PUT, DELETE, entre outros), o tipo do conteÃºdo da requisiÃ§Ã£o, o tamanho do conteÃºdo enviado na requisiÃ§Ã£o, qual aplicaÃ§Ã£o fez a requisiÃ§Ã£o, o domÃ­nio em que o usuÃ¡rio estÃ¡, entre outros.\n\n### MÃ©todos\n\nComo dito antes, nos cabeÃ§alhos Ã© possÃ­vel encontrar o mÃ©todo/verbo da requisiÃ§Ã£o, sendo os mais conhecidos:\n\n- GET\n- POST\n- PUT\n- DELETE\n\nEmbora nem sempre mudamos outros conteÃºdos do cabeÃ§alho, no servidores com **Express** sempre precisamos falar quais mÃ©todos estamos utilizando para uma determinada rota.\n\n> Navegadores por padrÃ£o utilizam apenas os mÃ©todos GET e POST, portanto, para utilizar outro mÃ©todo Ã© necessÃ¡rio utilizar JavaScript em uma requisiÃ§Ã£o.\n\n#### GET\n\nPor padrÃ£o Ã© utilizado quando queremos apenas o retorno de algum dado/pÃ¡gina do servidor.\n\n#### POST\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor. Geralmente usado para criar um dado novo no servidor ou fazer um login de usuÃ¡rio.\n\n#### PUT\n\nUtilizado quando estamos enviando dados, como um formulÃ¡rio para servidor, porÃ©m, desta vez estamos modificando um dado jÃ¡ existente.\n\n#### DELETE\n\nUtilizado quando queremos deletar um dado existente.\n\n## Corpo\n\nCorpo Ã© um espaÃ§o na requisiÃ§Ã£o HTTP onde os dados de um formulÃ¡rio sÃ£o enviados ao servidor. HÃ¡ vÃ¡rios tipos de conteÃºdos que podem ser enviados no corpo, por isso do campo `tipo de contÃ©udo` dentro dos cabeÃ§alhos.\n\n## ParÃ¢metros (Query String)\n\nParÃ¢metros, como o nome jÃ¡ indica, sÃ£o parÃ¢metros que passamos junto a rota, geralmente sÃ£o utilizados como filtros para alguma requisiÃ§Ã£o.\n\nUm exemplo de parÃ¢metro sendo passado para o servidor da Bing, onde pedimos ao servidor que nos retorne pesquisas relacionadas a `restapi`:\n\n```\nwww.bing.com/search?q=restapi\n```\n\nPara criar um parÃ¢metro precisamos iniciar com **`?`**, seguido de **`campo=valor`**, caso queira adicionar mais parÃ¢metros apenas insiria **`&`** seguido de **`campo=valor`**, como abaixo:\n\n```\nwww.bing.com/search?q=restapi&form=QBLH\n```\n\nGeralmente os parÃ¢metros sÃ£o utilizados junto ao mÃ©todo GET, para filtragem de resultados no servidor. PorÃ©m nada impede de ser usados junto a outro mÃ©todo HTTP.\n\n## Recapitulando REST com Express\n\nAgora que foi esclarecido alguns pontos principais de um servidor HTTP. Vamos ver alguns exemplos:\n\n---\n\n### GET\n\n- MÃ©todo: GET\n- Rota: /nomes:\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: retornar todos os nomes\n\n```js\napp.get('/nomes', (req, res) => {\n\t...\n})\n```\n\n---\n\n### GET com parÃ¢metros\n\n- MÃ©todo: GET\n- Rota: /nomes\n- ParÃ¢metros: `?maxLength=6&fisrtLetter=a`\n- URL: `http//localhost:3000/nomes?maxLength=6&fisrtLetter=a`\n- Funcionalidade: retornar todos os nomes com o tamanho mÃ¡ximo de **6** letras que comecem com a letra **a**\n\n```js\napp.get('/nomes', (req, res) => {\n\tconst { maxLength, firstLetter } = req.query // pega os parametros\n\t...\n})\n```\n\n---\n\n### GET com rota dinÃ¢mica\n\n- MÃ©todo: GET\n- Rota: /nomes/bruno\n- URL: `http//localhost:3000/nomes/bruno`\n- Funcionalidade: retornar informaÃ§Ãµes sobre o nome **bruno**\n\n```js\napp.get('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n---\n\n### POST\n\n- MÃ©todo: POST\n- Rota: /nomes\n- Corpo: `{ nome: 'bruno', significado: 'moreno, escuro' }`\n- URL: `http//localhost:3000/nomes`\n- Funcionalidade: criar um novo nome com significado\n\n```js\napp.post('/nomes', (req, res) => {\n\tconst { nome, significado } = req.body // pega campos do corpo\n\t...\n})\n```\n\n---\n\n### PUT\n\n- MÃ©todo: PUT\n- Rota dinÃ¢mica: /nomes/bruno\n- Corpo: { significado: 'claro' }\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: alterar o significado do nome **bruno**\n\n```js\napp.put('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\tconst { significado } = req.body // pega o campo do corpo\n\t...\n})\n```\n\n---\n\n### DELETE\n\n- MÃ©todo: DELETE\n- Rota dinÃ¢mica: /nomes/bruno\n- URL: `http://localhost:3000/nomes/bruno`\n- Funcionalidade: deletar o nome **bruno**\n\n```js\napp.delete('/nomes/:nome', (req, res) => {\n\tconst { nome } = req.params // pega valor da rota dinÃ¢mica\n\t...\n})\n```\n\n# Recapitulando\n\nFinalmente, completamos o que foi proposto nessa parte. Criamos nosso sistema de pastas, utilizamos o terminal para executar alguns comandos, inicializamos nosso repositÃ³rio, iniciamos o projeto com Yarn, instalamos alguns mÃ³dulos, criamos os scripts que vamos utilizar no projeto e foi explicado por cima como fazer uma requisiÃ§Ã£o HTTP.\n\nAgora estamos prontos para ir para a prÃ³xima fase, onde realmente colocamos a mÃ£o na massa e criamos nosso primeiro servidor com NodeJS.\n\nGostaria de agradecer de vocÃª ter chegado atÃ© aqui! Espero que eu tenha lhe passado algum conhecimento. EntÃ£o vamos para a parte 2 desse tutorial!","public_reactions_count":6,"tags":["nodejs","javascript"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531799/strapifolio/image_2fc3c358d2.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.57,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531800/strapifolio/thumbnail_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_2fc3c358d2","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.01,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/medium_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/medium_image_2fc3c358d2","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_2fc3c358d2","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.54,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531802/strapifolio/small_image_2fc3c358d2.webp","provider_metadata":{"public_id":"strapifolio/small_image_2fc3c358d2","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:46.876Z","reactions":6,"time":10,"suggestions":[{"title":"PostgreSQL + Docker = ğŸ’™","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, con...","content":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta prÃ¡tica de conteinerizaÃ§Ã£o possibilita uma configuraÃ§Ã£o rÃ¡pida de ambientes de desenvolvimento, testes e produÃ§Ã£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta grÃ¡fica de administraÃ§Ã£o que, por sua vez, tambÃ©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar vÃ¡rios contÃªineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSerÃ¡ demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar contÃªineres a partir de imagens](#clock4-criar-contÃªineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, Ã© esperado que vocÃª tenha conhecimento bÃ¡sico das tecnologias citadas. Certifique-se de que hÃ¡ instalado em sua mÃ¡quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial sÃ£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) sÃ£o pontes de comunicaÃ§Ã£o que possiblitam Ã  contÃªineres uma conexÃ£o entre eles. Geralmente, criasse uma network quando dois ou mias contÃªineres tÃªm uma relaÃ§Ã£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que serÃ¡ utilizada nesse tutorial, Ã© possÃ­vel ver quais outras networks estÃ£o sendo utilizadas em sua mÃ¡quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume Ã© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o contÃªiner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso serÃ¡ criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua mÃ¡quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar contÃªineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar Ã© preciso se atentar Ã  alguns detalhes:\n  \n- Imagens docker sÃ£o construÃ­das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tambÃ©m tÃªm uma versÃ£o, geralmente estes sÃ£o versÃµes do prÃ³prio produto/serviÃ§o escolhido, e caso nÃ£o seja especificado uma versÃ£o sempre serÃ¡ instalado a Ãºltima versÃ£o estÃ¡vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial serÃ¡ usado a imagem do PostgreSQL versÃ£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 vocÃª irÃ¡ usar a Ãºltima versÃ£o estÃ¡vel (mais abaixo). Siga o comando a baixo para criar um contÃªiner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta Ãºnica linha foi criado e executado um contÃªiner, em que:\n  \n- **-\\-name**, especificao nome do contÃªiner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a variÃ¡vel de ambiente do contÃªiner\n  - **POSTGRES_PASSWORD=postgresql**, Ã© a variÃ¡vel de ambiente que especificaa senha necessÃ¡ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta serÃ¡ exposta (**5440:5432**), ou seja, serÃ¡ acessÃ­vel de fora do docker (utilizar em uma aplicaÃ§Ã£o nÃ£o conteinerizada).\n- **-d**, especificaque apÃ³s criado o contÃªiner seu terminal se separe do contÃªiner e vocÃª consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o contÃªiner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o contÃªiner, neste caso a image **postgres**, versÃ£o **12.4** utilizando linux **alpine**.\n  \nÃ‰ possÃ­vel ver outras versÃµes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um contÃªiner utilizando a imagem do pgAdmin4 em sua Ãºltima versÃ£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando Ã© muito parecido com o utilizado para criar o contÃªiner do Postgres. EstÃ£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de variÃ¡veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTambÃ©m, por Ãºltimo se encontra o nome da imagem utilizada para criar o contÃªiner (**dpage/pgadmin4**), como pode ver, desta vez nÃ£o foi passado nenhuma versÃ£o especifica, portanto, por padrÃ£o Ã© instalado a Ãºltima versÃ£o estÃ¡vel da imagem, outro jeito de especificar a Ãºltima versÃ£o da imagem Ã© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJÃ¡ que foi criado os dois contÃªineres Ã© hora de testar se tudo estÃ¡ funcionando como esperado. Primeiro rode o comando abaixo para listar todos os contÃªineres em execuÃ§Ã£o em sua mÃ¡quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois contÃªineres ainda estejam em execuÃ§Ã£o vocÃª deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.sâ€¦\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta Ã© a mesma exposta na criaÃ§Ã£o do contÃªiner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"PÃ¡gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como variÃ¡veis de ambiente na criaÃ§Ã£o do contÃªiner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVocÃª serÃ¡ redirecionado para outra pÃ¡gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"PÃ¡gina inicial pgadmin\" width=\"384px\"/>\n  \nPorÃ©m, ainda nÃ£o hÃ¡ nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o botÃ£o direito em cima do \"Servers\" no canto superior esquerdo, vÃ¡ em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal serÃ¡ aberto onde vocÃª irÃ¡ inserir informaÃ§Ãµes sobre o servidor. No campo \"name\" adicione um nome de sua preferÃªncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do contÃªiner \"**postgres**\" (nome do contÃªiner Postgres).\n- No campo \"Port\" utilize a porta interna do contÃªiner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como estÃ¡.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como variÃ¡vel de ambiente na criaÃ§Ã£o do contÃªiner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no botÃ£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVerÃ¡ que o servidor foi criado e agora vocÃª tem acesso ao banco de dados do mesmo modo se nÃ£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados Ã© o nome do contÃªiner (**postgres**) e a porta Ã© a interna (**5432**). JÃ¡ para acesso externo, como em uma aplicaÃ§Ã£o feita em NodeJS, o host Ã© \"**localhost**\" ou \"**127.0.0.1**\" e a porta Ã© a porta externa especificada na criaÃ§Ã£o do contÃªiner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de criaÃ§Ã£o dos contÃªineres pode ser feito utilizando um arquivo que por convenÃ§Ã£o/padrÃ£o Ã© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, alÃ©m disso adiciona o conceito de **stack**.\n  \nStack nada mais Ã© que um conjunto de contÃªineres que tem uma relaÃ§Ã£o entre si, vocÃª pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack serÃ¡ o nome da pasta em que o arquivo estÃ¡. Ao criar uma network dentro de uma stack o nome desta network terÃ¡ como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para comeÃ§ar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack serÃ¡ **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua preferÃªncia e comece adicionando o bÃ¡sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que hÃ¡:\n  \n- **version** - versÃ£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, serÃ¡ nomeada **postgres-network**, pois serÃ¡ adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do contÃªiner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma Ãºnica linha, serÃ¡ criado um contÃªiner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora Ã© a vez de reescrever script do contÃªiner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTambÃ©m, como no contÃªiner **postgres**, estÃ¡ tudo bem parecido com escrito anteriormente utilizando uma Ãºnica linha. O nome, email, senha, porta e network continuam o mesmo, porÃ©m tambÃ©m foi adicionado um atributo novo, **depends_on**, este permite que o contÃªiner **pgadmin** nÃ£o seja criado/iniciado antes do contÃªiner **postgres** ser criado/iniciado.\n  \nPorÃ©m, antes de executar o arquivo serÃ¡ necessÃ¡rio deletar os contÃªineres jÃ¡ existente afinal nÃ£o serÃ£o mais utilizados como anteriormente, agora eles pertecerÃ£o Ã  uma stack. Primeiro pare os dois contÃªineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os contÃªineres configurados no arquivo sejam criandos, caso ainda nÃ£o exista, e os execute. Ainda, quando algo for alterado no arquivo os contÃªineres afetados serÃ£o reconstruidos.\n  \nEm algum momento, caso vocÃª queira parar todos os contÃªineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, jÃ¡ ter um arquivo/script de instalaÃ§Ã£o econimiza bastante tempo, afinal nÃ£o Ã© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na mÃ£o.\n  \n> O preguiÃ§oso sempre arruma um jeito de nÃ£o ter trabalho.\n  \nPor fim, agradeÃ§o vocÃª por ter chegado atÃ© aqui, deixe seu comentÃ¡rio e sugestÃ£o para os prÃ³ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":[{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso vocÃª nÃ£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conteÃºdos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a mÃ£o na massa](#botando-a-mÃ£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [ReorganizaÃ§Ã£o de cÃ³digo](#reorganizaÃ§Ã£o-de-cÃ³digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada alteraÃ§Ã£o importante no cÃ³digo fazer um commit. Isso permite que caso algo dÃª errado seja possÃ­vel recuperar a Ãºltima versÃ£o correta do cÃ³digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJÃ¡ temos nossa organizaÃ§Ã£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e comeÃ§armos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de cÃ³digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o prÃ³ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a mÃ£o na massa\nCom a pasta **server_node** aberta no VS Code como diretÃ³rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora Ã© preciso apenas comeÃ§ar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma variÃ¡vel, no nosso caso **app**,  como uma funÃ§Ã£o.\n\nAgora, diga ao **app** escutar requisiÃ§Ãµes na porta 3000, como estÃ¡ abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui Ã  app como uma funÃ§Ã£o\nconst app = express()\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente comeÃ§ou, temos um servidor que escuta na porta 3000 da nossa mÃ¡quina, porÃ©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplicaÃ§Ãµes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requiÃ§Ã£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisiÃ§Ãµes HTTP\n - falamos para o app/express utilizar o cors em sua execuÃ§Ã£o\n - falamos para o app/express utilizar o morgan em sua execuÃ§Ã£o\n - finalmente, criamos uma rota com o mÃ©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o bÃ¡sico bÃ¡sico de um servidor em node, porÃ©m atÃ© agora nÃ£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor Ã© um programa que fica sempre em execuÃ§Ã£o, apenas interrompido quando hÃ¡ algum erro ou outro programa/usuÃ¡rio forÃ§a sua interrupÃ§Ã£o, ele ficarÃ¡ esperando requisiÃ§Ãµes. Portanto, faÃ§a uma requisiÃ§Ã£o, pelo prÃ³prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, vocÃª receberÃ¡ um **ok** na pÃ¡gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, porÃ©m tambÃ©m nÃ£o se reinicia quando fizermos alguma alteraÃ§Ã£o no cÃ³digo, para isso preparamos o script **dev**. Portanto, interrompa a execuÃ§Ã£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJÃ¡ que programamos nossa primeira rota, Ã© hora de realmente retornar ao usuÃ¡rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois mÃ³dulos padrÃµes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, provÃª mÃ©todos para facilmente trabalhar com caminhos dentro do node\n- fs, provÃª mÃ©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na variÃ¡vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o mÃ©todo **readFileSync** do mÃ³dulo **fs** (sempre retorna string)\n - Fazemos o parse/transformaÃ§Ã£o da string para o formato json\n - Retornamos o json para o usuÃ¡rio\n\nÃ‰ pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usuÃ¡rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto Ã© possÃ­vel ver como funciona um servidor API Rest, o usuÃ¡rio faz uma requisiÃ§Ã£o e o retorno Ã© apenas em json, nada de HTML.\n\nNosso cÃ³digo estÃ¡ bem enxuto, e queremos isto, algo simples, de fÃ¡cil entendimento, porÃ©m que resolva o proposto. PorÃ©m, nÃ£o estamos tratando nenhuma exceÃ§Ã£o ou erro que possa acontecer durante a execuÃ§Ã£o.\n\nPara resolver esse problema vamos envolver todo o conteÃºdo dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usuÃ¡rio. Mas ainda nÃ£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usuÃ¡rio de cÃ³digo 200, e caso dÃª algum problema durante a execuÃ§Ã£o do nosso cÃ³digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usuÃ¡rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execuÃ§Ã£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento jÃ¡ estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. EntÃ£o, no prÃ³ximo criaremos a leitura de um dado apenas, baseado na rota que o usuÃ¡rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os mÃ©todo GET novamente, porÃ©m, utilizaremos uma rota dinÃ¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este nÃºmero adicional na rota nos darÃ¡ a capacidade de retornarmos ao usuÃ¡rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisiÃ§Ã£o do usuÃ¡rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisiÃ§Ãµes com metodo GET com um parÃ¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisiÃ§Ã£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma variÃ¡vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a variÃ¡vel nÃ£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usuÃ¡rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nTemos as duas requisiÃ§Ãµes com o mÃ©todo GET, para quando o usuÃ¡rio pedir todos os fatos e quando pedir apenas um fato com um especÃ­fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usuÃ¡rio seja capaz de criar um novo fato. \nNo corpo da requisiÃ§Ã£o pegaremos todos os campos necessÃ¡rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo POST\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto com as propriedades necessÃ¡rias, id, text, type e upvotes\n- adicionar o novo fato Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com metodo POST\napp.post('/', (request, response) => {\n\t// lÃª o campo text do corpo da requisiÃ§Ã£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usuÃ¡rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n### ALTERAR\nJÃ¡ que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usuÃ¡rio altere algum fato em nosso arquivo/banco a partir da rota dinÃ¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo PUT e ID\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com mÃ©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisiÃ§Ã£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas variÃ¡veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// variÃ¡vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usuÃ¡rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da alteraÃ§Ã£o, precisando do ID da rota, porÃ©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo DELETE e ID\n- ler arquivo e guardar em uma variÃ¡vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com o mÃ©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma variÃ¡vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o Ã­ndice do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do Ã­ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n\n# ReorganizaÃ§Ã£o de cÃ³digo\n## Criando controller\nSe vocÃª olhar para seu arquivo **server.js**  ele estÃ¡ enorme e Ã© difÃ­cil sua leitura, alÃ©m de que eventualmente nÃ³s podemos querer acrescentar mais funcionalidades, portando, mais cÃ³digo ao nosso projeto. \nPara uma melhor manutenÃ§Ã£o Ã© importante separarmos aquilo que Ã© de inicializaÃ§Ã£o/configuraÃ§Ã£o do servidor do que Ã© funcionalidade para o usuÃ¡rio.\nEntÃ£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara comeÃ§ar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os mÃ³dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a variÃ¡vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 mÃ©todos, index, show, create, update e delete, todos com os mesmo parÃ¢metros, request e  response, e ao final exportaremos a classe como um mÃ³dulo.\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO prÃ³ximo passo para organizarmos nosso cÃ³digo Ã© mover algumas partes de cÃ³digo que estÃ£o no **server.js** para este arquivo. Portanto, todo o cÃ³digo dentro de `app.get('/', (request, response){...})` ficarÃ¡ dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usuÃ¡rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nO mesmo serÃ¡ feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora nÃ£o estÃ¡ se comunicando com o servidor/Express e para deixar nosso cÃ³digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diretÃ³rio do arquivo **server.js**. Este arquivo irÃ¡ conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um mÃ³dulo, usando **./controllers/FactsController** para sinalizar que Ã© um mÃ³dulo criado no projeto. Importaremos tambÃ©m o mÃ³dulo Express, porÃ©m, dessa vez iniciaremos um roteador, e nÃ£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um mÃ³dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos cÃ³digos que nÃ£o estÃ£o mais sendo usados pelo servidor. EntÃ£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja fÃ¡cil a manutenÃ§Ã£o, ainda nÃ£o Ã© o ideal, mas Ã© o suficiente!\n\nSe vocÃª chegou atÃ© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu prÃ³prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma sÃ©rie de posts envolvendo o desenvolvimento de aplicaÃ§Ãµes Back End e Front End.\n\nDeixe seu comentÃ¡rio dizendo o que estÃ¡ bom e o que Ã© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":["[Circular ~.2.suggestions.0]","[Circular ~.2]"]},"[Circular ~.2]"]},{"title":"Criando um servidor em NodeJS - Parte 2","url":"https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7","slug":"criando-um-servidor-em-nodejs-parte-2-6g7","description":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON com...","content":"Esta Ã© parte 2 do tutorial de como fazer um servidor utilizando NodeJS, Express e um arquivo JSON como banco de dados. Caso vocÃª nÃ£o tenha visto a primeira parte acesse: [Criando um servidor em NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f)\n\n> RepositÃ³rio [https://github.com/devbaraus/post_server_node](https://github.com/devbaraus/post_server_node)\n> Meu site [baraus.dev](https://baraus.dev)\n\n## Tabela de conteÃºdos\n- [Utilizando o Git](#utilizando-o-git)\n- [Criando arquivo server](#criando-arquivo-server)\n- [Botando a mÃ£o na massa](#botando-a-mÃ£o-na-massa)\n- [Manipulando o arquivo json](#manipulando-o-arquivo-json)\n\t- [CRUD](#crud)\n\t\t- [LER](#ler)\n\t\t- [CRIAR](#criar)\n\t\t- [ALTERAR](#alterar)\n\t\t- [DELETAR](#deletar)\n- [ReorganizaÃ§Ã£o de cÃ³digo](#reorganizaÃ§Ã£o-de-cÃ³digo)\n\t- [Criando controller](#criando-controller)\n\t- [Criando sistema de rotas](#criando-sistema-de-rotas)\n\t- [Limpando o server.js](#limpando-o-serverjs)\n- [Recapitulando](#recapitulando)\n\n# Utilizando o Git\nLembre-se de a cada alteraÃ§Ã£o importante no cÃ³digo fazer um commit. Isso permite que caso algo dÃª errado seja possÃ­vel recuperar a Ãºltima versÃ£o correta do cÃ³digo.\nPara isso utilize os comandos abaixo:\n\n```bash\ngit add . # adiciona todos os arquivos alterados\ngit commit -am \"...\" # adicionar uma mensagem ao commit\ngit push # caso esteja usando github\n```\n\n# Criando arquivo server\n\nJÃ¡ temos nossa organizaÃ§Ã£o de pastas criada, package.json criado, pacotes instalados, agora falta apenas criarmos o arquivo **server.js** e comeÃ§armos a codar! :laptop:\nPara isso precisamos criar o arquivo **server.js** dentro da pasta **src**\n\n```bash\ntouch src/server.js # cria o arquivo dentro da pasta sem precisar entrar nela\n```\nCriado  o primeiro arquivo do projeto, vamos utilizar o editor de cÃ³digo \n<abbr title=\"Visual Studio Code\">VS Code</abbr>. Para abrirmos a pasta atual no VS Code utilizando o terminal execute  o prÃ³ximo comando\n\n```bash\ncode .  # Abre o editor vscode na pasta atual\n```\n\n# Botando a mÃ£o na massa\nCom a pasta **server_node** aberta no VS Code como diretÃ³rio raiz do projeto, procure pelo arquivo **server.js** dentro da pasta **src**. \n\nAgora Ã© preciso apenas comeÃ§ar a codar, para isso importamos os pacotes que instalamos anteriormente.\n\nImporte o pacote Express e atribua ele a uma variÃ¡vel, no nosso caso **app**,  como uma funÃ§Ã£o.\n\nAgora, diga ao **app** escutar requisiÃ§Ãµes na porta 3000, como estÃ¡ abaixo.\n\n```js\n// importa pacote express\nconst express = require('express')\n// atribui Ã  app como uma funÃ§Ã£o\nconst app = express()\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000\napp.listen(3000,  ()  =>  {\n\tconsole.warn(`Servidor escutando na porta 3000`)\n})\n```\nAgora nosso projeto realmente comeÃ§ou, temos um servidor que escuta na porta 3000 da nossa mÃ¡quina, porÃ©m, ainda falta alguns passos para conseguirmos receber algo.\n\nVamos configurar mais alguns pacotes para trabalhar junto ao Express.\n- importamos o cors, pacote que faz com que outras aplicaÃ§Ãµes consigam se comunicar com nosso servidor\n- importamos o morgan, gerador de logs de requiÃ§Ã£o.\n - falamos para o app/express utilizar um formato json para o corpo das requisiÃ§Ãµes HTTP\n - falamos para o app/express utilizar o cors em sua execuÃ§Ã£o\n - falamos para o app/express utilizar o morgan em sua execuÃ§Ã£o\n - finalmente, criamos uma rota com o mÃ©todo GET que retorna **'ok'**\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n  \n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n  \n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))\n\n// rota :GET / \napp.get('/', (request, response) => {  \n  return response.send('ok')  \n})\n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n  console.warn(`Servidor inicializador na porta 3000`)  \n})\n```\nCriamos o bÃ¡sico bÃ¡sico de um servidor em node, porÃ©m atÃ© agora nÃ£o executamos nosso servidor nenhuma vez. Para isso, no terminal, execute o script **start** que criamos.\n```bash\nyarn start\n```\nEste comando faz com que o NodeJS execute o arquivo **server.js**. Como um servidor Ã© um programa que fica sempre em execuÃ§Ã£o, apenas interrompido quando hÃ¡ algum erro ou outro programa/usuÃ¡rio forÃ§a sua interrupÃ§Ã£o, ele ficarÃ¡ esperando requisiÃ§Ãµes. Portanto, faÃ§a uma requisiÃ§Ã£o, pelo prÃ³prio navegador, na rota http://localhost:3000. Caso nada tenha dado errado, vocÃª receberÃ¡ um **ok** na pÃ¡gina, em formato HTML.\n\nUsando **`yarn start`** nosso servidor nunca para de funcionar, porÃ©m tambÃ©m nÃ£o se reinicia quando fizermos alguma alteraÃ§Ã£o no cÃ³digo, para isso preparamos o script **dev**. Portanto, interrompa a execuÃ§Ã£o do servidor usando as teclas de atalho **`CTRL + C`** no dentro do terminal e execute um novo comando usando yarn:\n\n```bash\nyarn dev \n```\n\n# Manipulando o arquivo json\n\nJÃ¡ que programamos nossa primeira rota, Ã© hora de realmente retornar ao usuÃ¡rio dados como uma API Rest.\nSeparei um arquivo json chamado [facts.json](https://icedrive.net/0/4fzX2PP8GY), com fatos sobre gatos,  para funcionar como nosso bancos nesse projeto. Baixe o arquivo e coloque-o na pasta **db** do nosso projeto e importe dois mÃ³dulos padrÃµes do NodeJS, abaixo dos antigos imports dentro do arquivo **server.js**:\n\n- path, provÃª mÃ©todos para facilmente trabalhar com caminhos dentro do node\n- fs, provÃª mÃ©todos para trabalhando com o sistema de arquivos do sistema operacional\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')  \n```\n\nLogo, utilizamos o modulo **path**  para resolver o caminho relativo do arquivo **server.js** ao arquivo **facts.json**  e guardamos na variÃ¡vel **dbPath**.\n\nDentro do antigo app.get(...) criamos uma nova funcionalidade.\n - Lemos o arquivo **facts.json** utilizando o mÃ©todo **readFileSync** do mÃ³dulo **fs** (sempre retorna string)\n - Fazemos o parse/transformaÃ§Ã£o da string para o formato json\n - Retornamos o json para o usuÃ¡rio\n\nÃ‰ pelo navegador, acesse http://localhost:3000/ e veja os mesmos dados do arquivo json sendo mostrado.\n\n```js\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, './db/facts.json')\n\n// rota :GET /  \napp.get('/', (request, response) => {  \n  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n  const data = fs.readFileSync(  \n  dbPath,  \n  'utf8',  \n  )  \n  // transforma a string em json  \n  const facts = JSON.parse(data)  \n  \n  // retorna o json para o usuÃ¡rio  \n  return response.json(facts)  \n})  \n```\n\nNeste ponto Ã© possÃ­vel ver como funciona um servidor API Rest, o usuÃ¡rio faz uma requisiÃ§Ã£o e o retorno Ã© apenas em json, nada de HTML.\n\nNosso cÃ³digo estÃ¡ bem enxuto, e queremos isto, algo simples, de fÃ¡cil entendimento, porÃ©m que resolva o proposto. PorÃ©m, nÃ£o estamos tratando nenhuma exceÃ§Ã£o ou erro que possa acontecer durante a execuÃ§Ã£o.\n\nPara resolver esse problema vamos envolver todo o conteÃºdo dentro `app.get(...)` em um try/catch.\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio  \n\t  return response.json(facts)  \n  } catch (e) {  \n   \n  }\n})\n```\nDessa forma, quando estiver algum erro podemos mandar algum status de resposta http para o usuÃ¡rio. Mas ainda nÃ£o terminamos, se tudo der certo precisamos enviar um status de resposta ao usuÃ¡rio de cÃ³digo 200, e caso dÃª algum problema durante a execuÃ§Ã£o do nosso cÃ³digo precisamos tratar de alguma forma e enviar um status de resposta 500.\nPara isso utilizaremos alguns status de reposta:\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 500 | Erro no servidor |\n\n```js\n// rota :GET /  \napp.get('/', (request, response) => {  \n  try{  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  const data = fs.readFileSync(  \n\t  dbPath,  \n\t  'utf8',  \n\t  )  \n\t  // transforma a string em json  \n\t  const facts = JSON.parse(data)  \n\t  \n\t  // retorna o json para o usuÃ¡rio com status 200  \n\t  return response.status(200).json(facts) \n  } catch (e) {  \n\t  // print mensagem de erro no terminal  \n\t  console.log(e)  \n  \n\t  // retorna mensagem de erro para o usuÃ¡rio com status 500  \n\t  return response.status(500).json({erro: 'Erro de execuÃ§Ã£o!'})\n  }\n})\n```\n\n## CRUD \nA partir deste momento jÃ¡ estamos criando um <abbr title=\"Create, Read, Update and Delete\">CRUD</abbr>  (Criar, Ler, Alterar e Deletar).\nNo passo anterior, criamos a leitura de todos os dados, sem nenhuma especifidade. EntÃ£o, no prÃ³ximo criaremos a leitura de um dado apenas, baseado na rota que o usuÃ¡rio acessar, o ID.\n\n### LER\n\n```js\napp.get('/:id', (request, response) => {...})\n```\nPara isso utilizamos os mÃ©todo GET novamente, porÃ©m, utilizaremos uma rota dinÃ¢mica com **:id**. Isto significa que agora conseguimos acessar [http://localhost:3000/1](http://localhost:3000/1) ou [http://localhost:3000/2](http://localhost:3000/2), e este nÃºmero adicional na rota nos darÃ¡ a capacidade de retornarmos ao usuÃ¡rio o fato de ID igual ao inserido por ele.\n\nBora codar a requisiÃ§Ã£o do usuÃ¡rio para um fato com ID.\n\n| status | quando |\n|-----|--|\n| 200 | Fatos encontrados |\n| 404| Nenhum fato for encontrado |\n| 500 | Erro no servidor |\n\n\n```js\n// ouve requisiÃ§Ãµes com metodo GET com um parÃ¢metro\napp.get('/:id', (request, response) {  \n\t// pega o ID requisiÃ§Ã£o  \n\tconst { id } = request.params  \n\ttry {  \n\t\t // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\t let data = fs.readFileSync(dbPath, 'utf8')  \n\t\t // inicializa uma variÃ¡vel nula  \n\t\t let fact = null  \n\t\t \n\t\t // transforma a string em json e pega o array facts\n\t\t data = JSON.parse(data)['facts']  \n\t\t \n\t\t // passa por todos os fatos  \n\t\t for (let index in data) {  \n\t\t\t // se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\t if (data[index]['id'] == id) {  \n\t\t\t\t // a variavel fact recebe o fato com ID\n\t\t\t\t fact = data[index]  \n\t\t\t\t // para o loop  \n\t\t\t\t break  \n\t\t\t }  \n\t\t}  \n\t\t // caso a variÃ¡vel nÃ£o tenha recebido nenhum fato  \n\t\t if (fact === null) {  \n\t\t\t // retorne uma mensagem de erro com o status 400  \n\t\t\t return response  \n\t\t\t .status(404)  \n\t\t\t .json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// retorne o fato encontrado para o usuÃ¡rio  \n\t\treturn response.json(fact)  \n\t} catch (e) {  \n\t\t // print do erro no terminal  \n\t\t console.log(e)  \n\t\t \n\t\t // retorne uma mensagem de erro com o status 500  \n\t\t return response  \n\t\t .status(500)  \n\t\t .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nTemos as duas requisiÃ§Ãµes com o mÃ©todo GET, para quando o usuÃ¡rio pedir todos os fatos e quando pedir apenas um fato com um especÃ­fico ID.\n\n### CRIAR\n\nPrecisamos possibilitar que o usuÃ¡rio seja capaz de criar um novo fato. \nNo corpo da requisiÃ§Ã£o pegaremos todos os campos necessÃ¡rios para criar um novo fato, neste caso, um campo de nome **text**.\nO algoritmo, de forma ampla, para essa funcionalidade Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo POST\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto com as propriedades necessÃ¡rias, id, text, type e upvotes\n- adicionar o novo fato Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o novo fato ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com metodo POST\napp.post('/', (request, response) => {\n\t// lÃª o campo text do corpo da requisiÃ§Ã£o  \n\tconst { text } = request.body  \n\ttry {  \n\t  // LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t  let data = fs.readFileSync(dbPath, 'utf8')  \n\t  \n\t  // transforma a string em json  \n\t  data = JSON.parse(data)  \n\t  \n\t  // cria um novo fato  \n\t  const newFact = {  \n\t\t  id: String(data['facts'].length + 1),  \n\t\t  text: text,  \n\t\t  type: 'cat',  \n\t\t  upvotes: 0,  \n\t  }  \n\t  \n\t  // adiciona o fato ao array de fatos  \n\t  data['facts'].push(newFact)  \n\t  \n\t  // sobrescreve o arquivo  \n\t  fs.writeFileSync(dbPath, JSON.stringify(data))  \n\t  \n\t  // retorna o fato criado ao usuÃ¡rio com o status 201  \n\t  return response.status(201).json(newFact)  \n\t} catch (e) {  \n\t  // print do erro no terminal  \n\t  console.log(e)  \n\t  \n\t  // retorne uma mensagem de erro com o status 500  \n\t  return response  \n\t  .status(500)  \n\t  .json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n### ALTERAR\nJÃ¡ que criamos, precisamos possibilitar que seja alterado algum dado existente, a partir de um ID. Portanto, dessa vez, iremos possibilitar que o usuÃ¡rio altere algum fato em nosso arquivo/banco a partir da rota dinÃ¢mica com **ID** e um corpo com campo **text**.\n\nO algoritmo, de forma ampla, desta vez Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo PUT e ID\n- pegar campo text do corpo da requisiÃ§Ã£o\n- ler arquivo e guardar em uma variÃ¡vel\n- criar um objeto recebendo o fato existente e alterando o campo text\n- adicionar o fato alterado Ã  variÃ¡vel com os dados do arquivo .json\n- sobrescrever o arquivo\n- retornar o fato alterado ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 201 | Fato criado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com mÃ©todo PUT e ID\napp.put('/:id', (request, response) => {  \n\t // pega o ID da rota\n\t const { id } = request.params  \n\t // pega o campo text do corpo da requisiÃ§Ã£o  \n\t const { text } = request.body  \n\t \n\t try {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa duas variÃ¡veis como nulas  \n\t\tlet fact = null  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// variÃ¡vel fact recebe o fato com ID  \n\t\t\t\tfact = data['facts'][index]  \n\t\t\t\t// guarda o index do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (fact === null) {  \n\t\t\t// retorne uma mensagem de erro com o status 404  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t// cria um objeto com o fato existente e altera o campo text\n\t\tconst updatedFact = {  \n\t\t\t...data['facts'][indexFact],  \n\t\t\ttext: text,  \n\t\t}  \n\n\t\t// guarda o objeto atualizado ao array de fatos  \n\t\tdata['facts'][indexFact] = updatedFact  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o fato atualizado com o status 200  \n\t\treturn response.status(200).json(updatedFact)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n })\n```\n\n### DELETAR\nFinalmente, precisamos possibilitar ao usuÃ¡rio a funcionalidade de deletar um fato existe. Esta funcionalidade segue a mesma ideia da alteraÃ§Ã£o, precisando do ID da rota, porÃ©m sem nenhum corpo.\nO algoritmo dessa funcionalidade, de forma ampla, Ã©:\n- ouvir requisiÃ§Ãµes com o mÃ©todo DELETE e ID\n- ler arquivo e guardar em uma variÃ¡vel\n- remover o fato com ID do array\n- sobrescrever o arquivo\n- retornar o um status ao usuÃ¡rio\n\n| status | quando |\n|-----|--|\n| 204 | Fato deleteado |\n| 404 | Fato nÃ£o encontrado |\n| 500 | Erro no servidor |\n\n```js\n// ouve requisiÃ§Ãµes com o mÃ©todo DELEte e ID\napp.delete('/:id', (request, response) => {  \n\t// pega o ID da rota \n\tconst { id } = request.params  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json como string  \n\t\tlet data = fs.readFileSync(dbPath, 'utf8')  \n\n\t\t// inicializa uma variÃ¡vel como  \n\t\tlet indexFact = null  \n\n\t\t// transforma a string em json  \n\t\tdata = JSON.parse(data)  \n\n\t\t// passa por todos os fatos  \n\t\tfor (let index in data['facts']) {  \n\t\t\t// se encontrar um fato com o mesmo ID que o usuÃ¡rio pediu  \n\t\t\tif (data['facts'][index]['id'] == id) {  \n\t\t\t\t// guarda o Ã­ndice do fato em questÃ£o  \n\t\t\t\tindexFact = index  \n\t\t\t\t// para o loop  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t\t// se a variÃ¡vel continua nula  \n\t\tif (indexFact == null) {  \n\t\t\treturn response  \n\t\t\t.status(404)  \n\t\t\t.json({ erro: 'Nenhum fato foi encontrado!' })  \n\t\t}  \n\t\t\n\t\t// remove um elemento do array a partir do Ã­ndice  \n\t\tdata['facts'].splice(indexFact, 1)  \n\n\t\t// sobrescreve o arquivo  \n\t\tfs.writeFileSync(dbPath, JSON.stringify(data))  \n\n\t\t// retorna o status 204  \n\t\treturn response.sendStatus(204)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n})\n```\n\n# ReorganizaÃ§Ã£o de cÃ³digo\n## Criando controller\nSe vocÃª olhar para seu arquivo **server.js**  ele estÃ¡ enorme e Ã© difÃ­cil sua leitura, alÃ©m de que eventualmente nÃ³s podemos querer acrescentar mais funcionalidades, portando, mais cÃ³digo ao nosso projeto. \nPara uma melhor manutenÃ§Ã£o Ã© importante separarmos aquilo que Ã© de inicializaÃ§Ã£o/configuraÃ§Ã£o do servidor do que Ã© funcionalidade para o usuÃ¡rio.\nEntÃ£o, nessa fase iremos reorganizar nossos arquivos e fazer uso da pasta **controllers** criada anteriormente ainda na parte 1.\nPara comeÃ§ar, vamos criar um arquivo chamado **FactsController.js** dentro da pasta **controllers**.\n\nDentro deste arquivo importaremos os mÃ³dulo **path** e **fs**, podemos apenas mover os importes do arquivo **server.js**; Moveremos a variÃ¡vel **dbPath** para dentro deste arquivo, ajustando o caminho; Criaremos uma classe com nome **FactsController** e dentro dessa classe criaremos 5 mÃ©todos, index, show, create, update e delete, todos com os mesmo parÃ¢metros, request e  response, e ao final exportaremos a classe como um mÃ³dulo.\n\n```js\n// importa mÃ³dulo path  \nconst path = require('path')  \n// importa mÃ³dulo fs  \nconst fs = require('fs')\n// guardamos o caminho para o arquivo json  \nconst dbPath = path.resolve(__dirname, '../db/facts.json')\n\nclass FactsController{\n\tindex(request, response){\n\t}\n\tshow(request,response){\n\t}\n\tcreate(request,response){\n\t}\n\tupdate(request,response){\n\t}\n\tdelete(request,response){\n\t}\n}\nmodules.export = FactsController\n```\nO prÃ³ximo passo para organizarmos nosso cÃ³digo Ã© mover algumas partes de cÃ³digo que estÃ£o no **server.js** para este arquivo. Portanto, todo o cÃ³digo dentro de `app.get('/', (request, response){...})` ficarÃ¡ dentro de index, assim:\n\n```js\nindex(request, response) {  \n\ttry {  \n\t\t// LÃª de forma sÃ­ncrona o arquivo json, como string  \n\t\tconst data = fs.readFileSync(dbPath, 'utf8')  \n\t\t\n\t\t// transforma a string em json  \n\t\tconst facts = JSON.parse(data)  \n\n\t\t// retorna o json para o usuÃ¡rio com status 200  \n\t\treturn response.status(200).json(facts)  \n\t} catch (e) {  \n\t\t// print do erro no terminal  \n\t\tconsole.log(e)  \n\n\t\t// retorne uma mensagem de erro com o status 500  \n\t\treturn response  \n\t\t.status(500)  \n\t\t.json({ erro: 'NÃ£o foi possÃ­vel executar esta operaÃ§Ã£o!' })  \n\t}\n}\n```\nO mesmo serÃ¡ feito para o outro GET, POST, PUT e DELETE. Seguindo o esquema abaixo.\n```\napp.get('/:id', (request, reponse)=>{...}) -> show(request, response){...}\napp.post('/', (request, reponse)=>{...}) -> create(request, response){...}\napp.put('/:id', (request, reponse)=>{...}) -> update(request, response){...}\napp.delete('/:id', (request, reponse)=>{...}) -> delete(request, response){...}\n```\n\n## Criando sistema de rotas\nNosso controller agora nÃ£o estÃ¡ se comunicando com o servidor/Express e para deixar nosso cÃ³digo ainda mais limpo criaremos um arquivo chamado **routes.js** no mesmo diretÃ³rio do arquivo **server.js**. Este arquivo irÃ¡ conter todas as rotas do nosso servidor, podendo, a medida que o servidor for crescendo, ser dividido em mais arquivos.\nNesse arquivo de rotas iremos importar o arquivo **FactsController.js**  como um mÃ³dulo, usando **./controllers/FactsController** para sinalizar que Ã© um mÃ³dulo criado no projeto. Importaremos tambÃ©m o mÃ³dulo Express, porÃ©m, dessa vez iniciaremos um roteador, e nÃ£o um servidor; Criaremos nossas rotas e exportaremos o arquivo como um mÃ³dulo.\n\n```js\nconst router = require('express').Router()  \nconst FactsController = require('./controllers/FactsController')  \n  \nconst factsController = new FactsController()  \n  \n// Retorna todos fatos  \nrouter.get('/', factsController.index)  \n  \n// Retorna um fato  \nrouter.get('/:id', factsController.show)  \n  \n// Cria um novo fato  \nrouter.post('/', factsController.create)  \n  \n// Edita um fato  \nrouter.put('/:id', factsController.update)  \n  \n// Deleta um fato  \nrouter.delete('/:id', factsController.delete)  \n  \nmodule.exports = router\n```\n\n## Limpando o server.js\nDentro do arquivo **server.js**, agora temos cÃ³digos que nÃ£o estÃ£o mais sendo usados pelo servidor. EntÃ£o vamos dar uma limpa e colocar nosso servidor para funcionar novamente!\n\nExclua todos os `app.get`, `app.post`, `app.put` e `app.delete`, importe o arquivo de rotas criado anteriormente e fale para o servidor usar esse arquivo de rotas .\n\n```js\n// importa pacote express  \nconst express = require('express')  \n// importa pacote cors  \nconst cors = require('cors')  \n// importa pacote morgan  \nconst morgan = require('morgan')  \n// importa rotas pelo arquivo routes.js  \nconst routes = require('./routes')  \n\n// atribui a variavel o express como uma funÃ§Ã£o  \nconst app = express()  \n\n// app usa corpo em json  \napp.use(express.json())  \n// app usa cors  \napp.use(cors())  \n// app usa gerador de log morgan  \napp.use(morgan('dev'))  \n\n// utilize o arquivo de rotas\napp.use('/', routes)  \n\n// inicia servidor escutando requisiÃ§Ãµes na porta 3000  \napp.listen(3000, () => {  \n\tconsole.warn(`Servidor inicializador na porta 3000`)  \n})\n```\n\n# Recapitulando\nNeste ponto nosso projeto chega ao fim, criamos todas rotas de um CRUD, manipulamos o arquivo JSON e organizamos nossos arquivo de um maneira que seja fÃ¡cil a manutenÃ§Ã£o, ainda nÃ£o Ã© o ideal, mas Ã© o suficiente!\n\nSe vocÃª chegou atÃ© aqui espero que tenha aprendido como criar um servidor NodeJS e consigar criar o seu prÃ³prio sem grandes dificildades. \n\nEstas duas partes foram meus primeiros posts, ainda pretendo criar uma sÃ©rie de posts envolvendo o desenvolvimento de aplicaÃ§Ãµes Back End e Front End.\n\nDeixe seu comentÃ¡rio dizendo o que estÃ¡ bom e o que Ã© preciso melhorar nos posts. ","public_reactions_count":1,"tags":["nodejs","javascript","json"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/image_53b250ea1b.webp","alternativeText":"Cover Criando um Servidor NodeJS","formats":{"thumbnail":{"name":"thumbnail_image.jpg","hash":"thumbnail_image_53b250ea1b","ext":".jpg","mime":"image/png","width":245,"height":123,"size":5.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531765/strapifolio/thumbnail_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_image_53b250ea1b","resource_type":"image"}},"medium":{"name":"medium_image.jpg","hash":"medium_image_53b250ea1b","ext":".jpg","mime":"image/png","width":750,"height":375,"size":17.06,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531767/strapifolio/medium_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/medium_image_53b250ea1b","resource_type":"image"}},"small":{"name":"small_image.jpg","hash":"small_image_53b250ea1b","ext":".jpg","mime":"image/png","width":500,"height":250,"size":10.56,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616531768/strapifolio/small_image_53b250ea1b.webp","provider_metadata":{"public_id":"strapifolio/small_image_53b250ea1b","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:36:17.837Z","reactions":1,"time":15,"suggestions":[{"title":"PostgreSQL + Docker = ğŸ’™","url":"https://dev.to/devbaraus/postgresql-docker-5c3n","slug":"postgresql-docker-5c3n","description":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, con...","content":"Assim como vÃ¡rias outra tÃ©cnologias, o PostgreSQL tambÃ©m disponibiliza sua versÃ£o conteinerizada, conhecido como imagem, para ser executada usando Docker. Esta prÃ¡tica de conteinerizaÃ§Ã£o possibilita uma configuraÃ§Ã£o rÃ¡pida de ambientes de desenvolvimento, testes e produÃ§Ã£o.\n  \nOs familiarizados ao SGBD sabem que este tem uma ferramenta grÃ¡fica de administraÃ§Ã£o que, por sua vez, tambÃ©m disponibiliza uma imagem gratuita e que pode ser utilizado em qualquer sistema operacional que suporte Docker. E os familiarizados ao Docker sabem que existe uma forma simples de executar vÃ¡rios contÃªineres, o Docker Compose, utilizando um arquivo YAML.\n  \nSerÃ¡ demonstrado neste tutorial:\n  \n- [:clock12: Criar uma network](#clock12-criar-uma-network )\n- [:clock2: Criar um volume](#clock2-criar-um-volume )\n- [:clock4: Criar contÃªineres a partir de imagens](#clock4-criar-contÃªineres-a-partir-de-imagens )\n- [:clock6: Acessar o banco usando pgAdmin4](#clock6-acessar-o-banco-usando-pgadmin4 )\n- [:clock8: Criar arquivo YAML](#clock8-criar-arquivo-yaml )\n- [:link: Links](#link-links )\n  \nPortanto, Ã© esperado que vocÃª tenha conhecimento bÃ¡sico das tecnologias citadas. Certifique-se de que hÃ¡ instalado em sua mÃ¡quina o [Docker](https://docs.docker.com/get-docker/ ) e [Docker Compose](https://docs.docker.com/compose/install/ ). Ainda, se atente que todos comandos mostrados neste tutorial sÃ£o executados utilizando um terminal.\n  \n#  :clock12: Criar uma network\n  \n  \nNetwork (rede) sÃ£o pontes de comunicaÃ§Ã£o que possiblitam Ã  contÃªineres uma conexÃ£o entre eles. Geralmente, criasse uma network quando dois ou mias contÃªineres tÃªm uma relaÃ§Ã£o e comunicam-se. Portanto, para este caso crie uma network chamada **postgres-network** utilizando o comando abaixo:\n  \n```sh\ndocker network create -d bridge postgres-network\n```\n  \nCriado a network que serÃ¡ utilizada nesse tutorial, Ã© possÃ­vel ver quais outras networks estÃ£o sendo utilizadas em sua mÃ¡quina:\n  \n```sh\ndocker network ls\n```\n  \n| NETWORK ID   | NAME                 | DRIVER | SCOPE |\n| ------------ | -------------------- | ------ | ----- |\n| a8d59bf0f5bb | bridge               | bridge | local |\n| c0beeb145f0d | host                 | host   | local |\n| d539d7388de2 | **postgres-network** | bridge | local |\n  \n#  :clock2: Criar um volume\n  \n  \nVolume Ã© o jeito utilizado no Docker para criar uma armazenamento persistente de dados, ou seja, ao desligar o contÃªiner os dados continuam existindo.\nPara criar um volume utilize o comando abaixo, neste caso serÃ¡ criando um volume chamado **postgres-data**:\n  \n```sh\ndocker volume create --name=postgres-data\n```\n  \nPara listar todos volumes existentes em sua mÃ¡quina utilize o comando:\n  \n```sh\ndocker volume ls\n```\n  \n| DRIVER | VOLUME NAME                 |\n| ------ | --------------------------- |\n| local  | 2b168382f98fc0280482b760893 |\n| local  | portainer_data              |\n| local  | **postgres-data**           |\n  \n#  :clock4: Criar contÃªineres a partir de imagens\n  \n  \nAntes de escolher uma imagem docker para utilizar Ã© preciso se atentar Ã  alguns detalhes:\n  \n- Imagens docker sÃ£o construÃ­das em cima de alguma imagem de sistema operacional, geralmente linux, e cada imagem linux tem um tamanho.\n- Imagens tambÃ©m tÃªm uma versÃ£o, geralmente estes sÃ£o versÃµes do prÃ³prio produto/serviÃ§o escolhido, e caso nÃ£o seja especificado uma versÃ£o sempre serÃ¡ instalado a Ãºltima versÃ£o estÃ¡vel.\n  \nTendo os detalhes citados acima em mente, neste tutorial serÃ¡ usado a imagem do PostgreSQL versÃ£o **12.4**, baseada na imagem linux **Alpine** de **~ 5MB**, e para a imagem do pgAdmin4 vocÃª irÃ¡ usar a Ãºltima versÃ£o estÃ¡vel (mais abaixo). Siga o comando a baixo para criar um contÃªiner do PostgreSQL:\n  \n```sh\ndocker run --name postgres --network=postgres-network -e \"POSTGRES_PASSWORD=postgresql\" -v postgres-data:/var/lib/postgresql/data -p 5440:5432 -d postgres:12.4-alpine\n```\n  \nNesta Ãºnica linha foi criado e executado um contÃªiner, em que:\n  \n- **-\\-name**, especificao nome do contÃªiner (**postgres**)\n- **-\\-network**, especificaa rede (**postgres_network**)\n- **-e**, especifica a variÃ¡vel de ambiente do contÃªiner\n  - **POSTGRES_PASSWORD=postgresql**, Ã© a variÃ¡vel de ambiente que especificaa senha necessÃ¡ria para ter acesso ao banco de dados.\n- **-v**, especifica o volume utilizado para persistir os dados (**postgres-data**).\n- **-p**, especificaqual porta serÃ¡ exposta (**5440:5432**), ou seja, serÃ¡ acessÃ­vel de fora do docker (utilizar em uma aplicaÃ§Ã£o nÃ£o conteinerizada).\n- **-d**, especificaque apÃ³s criado o contÃªiner seu terminal se separe do contÃªiner e vocÃª consiga utilizando sem ter que iniciar um novo terminal, ou tenha que parar o contÃªiner.\n- **postgres:12.4-alpine**, por fim o nome da imagem utilizada para criar o contÃªiner, neste caso a image **postgres**, versÃ£o **12.4** utilizando linux **alpine**.\n  \nÃ‰ possÃ­vel ver outras versÃµes de imagens PostgreSQL acessando: [https://hub.docker.com/\\_/postgres](https://hub.docker.com/_/postgres )\n  \nAgora, crie um contÃªiner utilizando a imagem do pgAdmin4 em sua Ãºltima versÃ£o utilizando o seguinte comando:\n  \n```sh\ndocker run --name pgadmin --network=postgres-network -p 15432:80 -e \"PGADMIN_DEFAULT_EMAIL=example@example.com\" -e \"PGADMIN_DEFAULT_PASSWORD=pgadmin1234\" -d dpage/pgadmin4\n```\n  \nEste comando Ã© muito parecido com o utilizado para criar o contÃªiner do Postgres. EstÃ£o presentes os atributos **name**, **network**, **p**, **d**, e dessa vez 2 atributos **e** de variÃ¡veis de ambiente:\n  \n- **PGADMIN_DEFAULT_EMAIL**, email de login (**example@example.com**).\n- **PGADMIN_DEFAULT_PASSWORD**, senha de login (**pgadmin1234**)\n  \nTambÃ©m, por Ãºltimo se encontra o nome da imagem utilizada para criar o contÃªiner (**dpage/pgadmin4**), como pode ver, desta vez nÃ£o foi passado nenhuma versÃ£o especifica, portanto, por padrÃ£o Ã© instalado a Ãºltima versÃ£o estÃ¡vel da imagem, outro jeito de especificar a Ãºltima versÃ£o da imagem Ã© usando **dpage/pgadmin:latest**.\n  \n#  :clock6: Acessar o banco usando pgAdmin4\n  \n  \nJÃ¡ que foi criado os dois contÃªineres Ã© hora de testar se tudo estÃ¡ funcionando como esperado. Primeiro rode o comando abaixo para listar todos os contÃªineres em execuÃ§Ã£o em sua mÃ¡quina:\n  \n```sh\ndocker ps\n```\n  \nCaso os dois contÃªineres ainda estejam em execuÃ§Ã£o vocÃª deve ver algo similar ao mostrado abaixo:\n  \n| CONTAINER ID | IMAGE           | COMMAND                | CREATED       | STATUS     | PORTS                          | NAMES    |\n| ------------ | --------------- | ---------------------- | ------------- | ---------- | ------------------------------ | -------- |\n| cdb6a40baab2 | dpage/pgadmin4  | \"/entrypoint.sh\"       | 1 minute ago  | Up 2 hours | 443/tcp, 0.0.0.0:15432->80/tcp | pgadmin  |\n| 0e4fbee2549d | postgres:alpine | \"docker-entrypoint.sâ€¦\" | 4 minutes ago | Up 2 hours | 0.0.0.0:5440->5432/tcp         | postgres |\n  \nUsando um navegador acesse [http://localhost:15432](http://localhost:15432 ), repare que a porta Ã© a mesma exposta na criaÃ§Ã£o do contÃªiner pgadmin (**15432**).\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599955688/public/posts/postgres_docker/pgadmin_home_zlmwe0.webp\" alt=\"PÃ¡gina de login do pgAdmin4\" width=\"384px\"/>\n  \nAdicione o email e senha passados como variÃ¡veis de ambiente na criaÃ§Ã£o do contÃªiner e clique em \"login\".\n  \n- email: example@example.com\n- senha: pgadmin1234\n  \nVocÃª serÃ¡ redirecionado para outra pÃ¡gina, como esta:\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956024/public/posts/postgres_docker/home_page_jkqkvx.webp\" alt=\"PÃ¡gina inicial pgadmin\" width=\"384px\"/>\n  \nPorÃ©m, ainda nÃ£o hÃ¡ nenhum servidor de banco de dados configurado. Para adicionar um novo, clique com o botÃ£o direito em cima do \"Servers\" no canto superior esquerdo, vÃ¡ em \"Create\" e em seguinda em \"Server...\"\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599956015/public/posts/postgres_docker/criar_server_zpdjjz.webp\" alt=\"Criando um novo servidor\" width=\"384px\"/>\n  \nUm modal serÃ¡ aberto onde vocÃª irÃ¡ inserir informaÃ§Ãµes sobre o servidor. No campo \"name\" adicione um nome de sua preferÃªncia e clique na aba \"Connection\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958047/public/posts/postgres_docker/modal_step_1_vek8lp.webp\" alt=\"Modal passo 1\" width=\"384px\"/>\n  \n  \nNesta dela siga os passos:\n  \n- No campo \"Host name/address\", adicione o nome do contÃªiner \"**postgres**\" (nome do contÃªiner Postgres).\n- No campo \"Port\" utilize a porta interna do contÃªiner \"**5432**\".\n- Deixe o campo \"Maintenance database\" como estÃ¡.\n- No campo \"Username\" adicione \"**postgres**\".\n- No campo \"Password\" adicione a senha usada como variÃ¡vel de ambiente na criaÃ§Ã£o do contÃªiner do PostgreSQL (\"**postgresql**\").\n  \nAo final, clique no botÃ£o \"Save\".\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958290/public/posts/postgres_docker/modal_step_2_vxf4gs.webp\" alt=\"Modal passo 2\" width=\"384px\"/>\n  \nVerÃ¡ que o servidor foi criado e agora vocÃª tem acesso ao banco de dados do mesmo modo se nÃ£o estivesse usando docker.\n  \n<img src=\"https://res.cloudinary.com/dmzu6cgre/image/upload/v1599958693/public/posts/postgres_docker/servidor_criado_tb8pxh.webp\" alt=\"Servidor Criado\" width=\"384px\"/>\n  \nLembre-se que para acesso interno o host do banco de dados Ã© o nome do contÃªiner (**postgres**) e a porta Ã© a interna (**5432**). JÃ¡ para acesso externo, como em uma aplicaÃ§Ã£o feita em NodeJS, o host Ã© \"**localhost**\" ou \"**127.0.0.1**\" e a porta Ã© a porta externa especificada na criaÃ§Ã£o do contÃªiner (**5440**).\n  \n#  :clock8: Criar arquivo YAML\n  \n  \nTodo o passo de criaÃ§Ã£o dos contÃªineres pode ser feito utilizando um arquivo que por convenÃ§Ã£o/padrÃ£o Ã© chamado `docker-compose.yml` e utiliza o Docker Compose como seu gerenciador, alÃ©m disso adiciona o conceito de **stack**.\n  \nStack nada mais Ã© que um conjunto de contÃªineres que tem uma relaÃ§Ã£o entre si, vocÃª pode criar quantas stacks quiser. Lembrando que sempre que criar um arquivo **docker-compose.yml**, a stack serÃ¡ o nome da pasta em que o arquivo estÃ¡. Ao criar uma network dentro de uma stack o nome desta network terÃ¡ como prefixo o nome da stack (exemplo logo abaixo).\n  \nPortanto, para comeÃ§ar, crie um arquivo com o nome **docker-compose.yml** dentro de uma pasta nomeada **postgres**, sendo assim a stack serÃ¡ **postgres**.\n  \nEm seguida, abra o arquivo em um editor de texto de sua preferÃªncia e comece adicionando o bÃ¡sico:\n  \n```yaml\nversion: \"3\"\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nEm que hÃ¡:\n  \n- **version** - versÃ£o do Compose.\n- **networks** - networks a serem criadas dentro da stack.\n  - **network** - esta network, como dita antes, serÃ¡ nomeada **postgres-network**, pois serÃ¡ adicionado o prefixo da stack.\n- **volumes** - volumes (armazenamentos) a serem criadas dentro da stack.\n  \nRearraje o script do contÃªiner **postgres** ao arquivo:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nComo feito antes utilizando o script de uma Ãºnica linha, serÃ¡ criado um contÃªiner com o nome \"**postgres**\", senha \"**postgresql**\", porta \"**5440:5432**\", network \"**postgres-network**\" (lembre do prefixo), e volume.\n  \nAgora Ã© a vez de reescrever script do contÃªiner do **pgadmin**:\n  \n```yaml\nversion: \"3\"\n  \nservices:\n  postgres-compose:\n    image: postgres:12.4-alpine\n    container_name: postgres\n    environment:\n      POSTGRES_PASSWORD: \"postgresql\"\n    ports:\n      - \"5440:5432\"\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    networks:\n      - network\n  \n  pgadmin-compose:\n    image: dpage/pgadmin4\n    container_name: pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: \"example@example\"\n      PGADMIN_DEFAULT_PASSWORD: \"pgadmin1234\"\n    ports:\n      - \"15432:80\"\n    depends_on:\n      - postgres-compose\n    networks:\n      - network\n  \nnetworks:\n  network:\n    driver: bridge\n  \nvolumes:\n  postgres-data:\n    external: true\n```\n  \nTambÃ©m, como no contÃªiner **postgres**, estÃ¡ tudo bem parecido com escrito anteriormente utilizando uma Ãºnica linha. O nome, email, senha, porta e network continuam o mesmo, porÃ©m tambÃ©m foi adicionado um atributo novo, **depends_on**, este permite que o contÃªiner **pgadmin** nÃ£o seja criado/iniciado antes do contÃªiner **postgres** ser criado/iniciado.\n  \nPorÃ©m, antes de executar o arquivo serÃ¡ necessÃ¡rio deletar os contÃªineres jÃ¡ existente afinal nÃ£o serÃ£o mais utilizados como anteriormente, agora eles pertecerÃ£o Ã  uma stack. Primeiro pare os dois contÃªineres `docker stop postgres pgadmin` em seguida os remova `docker rm postgres pgadmin`.\n  \nAgora, rode o comando para executar o arquivo **docker-compose.yml** utilizando o Docker Compose:\n  \n```sh\ndocker-compose up -d\n```\n  \nEste comando faz com que os contÃªineres configurados no arquivo sejam criandos, caso ainda nÃ£o exista, e os execute. Ainda, quando algo for alterado no arquivo os contÃªineres afetados serÃ£o reconstruidos.\n  \nEm algum momento, caso vocÃª queira parar todos os contÃªineres do arquivo, utilize o comando:\n  \n```sh\ndocker-compose down\n```\n  \nE para remover:\n  \n```sh\ndocker-compose rm\n```\n  \n---\n  \nPessoalmente, gosto de guardar arquivos, scripts e instaladores, pois, estou sempre testando algo novo e algumas vezes isso resulta em ter que formatar o computador. Portanto, jÃ¡ ter um arquivo/script de instalaÃ§Ã£o econimiza bastante tempo, afinal nÃ£o Ã© preciso ter que ir na internet buscar como configurar ou ter que reconfigurar na mÃ£o.\n  \n> O preguiÃ§oso sempre arruma um jeito de nÃ£o ter trabalho.\n  \nPor fim, agradeÃ§o vocÃª por ter chegado atÃ© aqui, deixe seu comentÃ¡rio e sugestÃ£o para os prÃ³ximos posts, e caso este post tenha te ajudado deixe seu like. :thumbsup:\n  \n#  :link: Links\n  \n  \nSite pessoal: [baraus.dev](https://baraus.dev )\nGitHub: [@devbaraus](https://github.com/devbaraus )\nInstagram: [@devbaraus](https://instagram.com/devbaraus )\n  \nTutoriais:\n  \n- [Como criar um servidor NodeJS - Parte 1](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-1-c7f )\n- [Como criar um servidor em NodeJS - Parte 2](https://dev.to/devbaraus/criando-um-servidor-em-nodejs-parte-2-6g7 )\n  ","public_reactions_count":12,"tags":["docker","dockercompose","postgres","pgadmin"],"cover":{"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529843/strapifolio/giqwnosoyr1eoi9krojf_8aad36d5bc.webp","alternativeText":"Cover Postgres + Docker","formats":{"thumbnail":{"name":"thumbnail_giqwnosoyr1eoi9krojf.png","hash":"thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":245,"height":103,"size":6.92,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529844/strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/thumbnail_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"medium":{"name":"medium_giqwnosoyr1eoi9krojf.png","hash":"medium_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":750,"height":315,"size":28.63,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529845/strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/medium_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}},"small":{"name":"small_giqwnosoyr1eoi9krojf.png","hash":"small_giqwnosoyr1eoi9krojf_8aad36d5bc","ext":".png","mime":"image/png","width":500,"height":210,"size":16.3,"path":null,"url":"https://res.cloudinary.com/dmzu6cgre/image/upload/v1616529846/strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc.webp","provider_metadata":{"public_id":"strapifolio/small_giqwnosoyr1eoi9krojf_8aad36d5bc","resource_type":"image"}}}},"updatedAt":"2021-03-23T20:35:35.713Z","reactions":12,"time":10,"suggestions":["[Circular ~.2.suggestions.1]","[Circular ~.2]"]},"[Circular ~.2]"]}]}]